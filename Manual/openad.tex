\documentclass{book}

\usepackage[verbose]{wrapfig}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{url}
\usepackage{pdflscape}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{relsize}
\usepackage{moreverb}
\usepackage{longtable}
\usepackage{boxedminipage}
\usepackage{array}

\usepackage[pdftex,usenames]{color}
\usepackage[pdftex]{graphicx}  
\DeclareGraphicsExtensions{.pdf}  
\usepackage[%
  pdftex,%	
  bookmarks=true,%
  bookmarksnumbered=true,%
  hypertexnames=false,%
  pdfstartview=FitH,%		
  bookmarks=true,%	
  bookmarksopen=true,%
  breaklinks=true,%
  colorlinks=true,%
  linkcolor=blue,anchorcolor=blue,%
  citecolor=blue,filecolor=blue,%
  menucolor=blue,pagecolor=blue,%
  urlcolor=blue]{hyperref}
\hypersetup{
  pdfauthor = {Jean Utke, Uwe Naumann, Andrew Lyons},
  pdftitle = {OpenAD/F: User Manual},
  pdfsubject = {user manual},
  pdfkeywords = {OpenAD, Fortran, automatic differentiation, algorithms},
  pdfcreator = {LaTeX with hyperref package},
  pdfproducer = {pdflatex}
}
\pdfadjustspacing=1

% make paragraphs show up in the bookmarks
\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{6}


% page layout
% letter size
\paperheight     11in
\paperwidth      8.5in
% print area
\leftmargin      0in
\rightmargin     0in
\textheight      9.5in
\textwidth       7.5in
\topmargin      -0.5in
%\headheight      0in
%\headsep         0in
\oddsidemargin  -0.5in
\evensidemargin -0.5in


\fboxsep.5mm

% names and CS terms
\newcommand{\angel}{angel}
\newcommand{\entry}{entry}
\newcommand{\exit}{exit}
\newcommand{\Loop}{loop}
\newcommand{\EndLoop}{endloop}
\newcommand{\branch}{branch}
\newcommand{\EndBranch}{endbranch}
\newcommand{\basicblock}{basicblock}
\newcommand{\mfefninety}{mfef90}
\newcommand{\OpenADF}{OpenAD/F}
\newcommand{\OpenAD}{OpenAD}
\newcommand{\OpenADFortTk}{OpenADFortTk}
\newcommand{\OpenAnalysis}{OpenAnalysis}
\newcommand{\OpenSixtyFour}{Open64}
\newcommand{\saxpy}{saxpy}
\newcommand{\xaif}{XAIF}
\newcommand{\xaifBooster}{xaifBooster}
\newcommand{\whirl}{whirl}
\newcommand{\whirlToxaif}{whirl2xaif}
\newcommand{\whirlTof}{whirl2f}
\newcommand{\xaifTowhirl}{xaif2whirl}

% math
\newcommand{\R}{I\!\!R}
\newcommand{\bmb}{\mbox{\bf\em b}}
\newcommand{\bmC}{\mbox{\bf\em C}}
\newcommand{\bmf}{\mbox{\bf\em f}}
\newcommand{\bmfp}{\mbox{\bf\em f$\,^\prime\!\!$}}
\newcommand{\bmg}{\mbox{\bf\em g}}
\newcommand{\bmI}{\mbox{\bf\em I}}
\newcommand{\bmJ}{\mbox{\bf\em J}}
\newcommand{\bmS}{\mbox{\bf\em S}}
\newcommand{\bmu}{\mbox{\bf\em u}}
\newcommand{\bmv}{\mbox{\bf\em v}}
\newcommand{\bmw}{\mbox{\bf\em w}}
\newcommand{\bmx}{\mbox{\bf\em x}}
\newcommand{\bmy}{\mbox{\bf\em y}}

% environments
\newcommand{\refcan}[1]{(C\ref{#1})}
\newcommand{\refsec}[1]{{sec.~\ref{#1}}} 
\newcommand{\refsecs}[2]{{sects.~\ref{#1},\ref{#2}}}
\newcommand{\refsecBS}[1]{{Section~\ref{#1}}} 
\newcommand{\reffig}[1]{{fig.~\ref{#1}}} 
\newcommand{\reffigBS}[1]{{Figure\ref{#1}}} 
\newcommand{\reftab}[1]{{table~\ref{#1}}} 
\newcommand{\refalg}[1]{{alg.~\ref{#1}}} 
\newcommand{\refalgBS}[1]{{Algorithm~{#1}}} 
\newcommand{\refeqn}[1]{{(\ref{#1})}} 
\newcommand{\refdef}[1]{{Def.~(\ref{#1})}} 
\newtheorem{Can}{Canonicalization}

\newcommand{\nav}[1]{
\begin{tabular}{|m{.03\textwidth}|m{.92\textwidth}|}\hline
\vspace{1mm}
\includegraphics[width=.03\textwidth]{windrose_zh1}&
\vspace{1mm}
\begin{minipage}[c]{.86\textwidth}
\small {#1}
\end{minipage}
\vspace{1mm}
\\\hline
\end{tabular}
} 


\let\verbatiminput=\verbatimtabinput
\def\verbatimtabsize{8\relax}

\makeindex

\title{OpenAD/F: User Manual}
\author{J.~Utke  \\
	U.~Naumann \\
	A.~Lyons \\\\
\scriptsize draft \input{versionInfo.txt} \\
\scriptsize compiled on \today\ with \\
\framebox{
\begin{minipage}{6.5cm}
\tiny
\verbatiminput{versionInfoOpenAD.txt}
\end{minipage}
}
\vspace{4cm}
\\
\includegraphics[width=.2\textwidth]{savetree.jpg}\\[1ex]
\Large This is hyperref'ed PDF and should be viewed in a \\[.5ex]
\Large PDF reader instead of being printed!
}
\date{ }

\fancyhead[RE]{\leftmark}
\fancyhead[LE]{}
\fancyhead[RO]{}
\fancyhead[LO]{\nouppercase\rightmark}
\fancyfoot[LE,RO]{\input{versionInfo.txt}}
\fancyfoot[LO,RE]{OpenAD/F: User Manual}

\begin{document}
\maketitle
 \addcontentsline{toc}{chapter}{Contents}
\pagenumbering{roman}
\tableofcontents
\listoffigures
\listoftables

\pagestyle{fancy}
\pagenumbering{arabic}
\lstloadlanguages{Fortran,XML}
\lstset{basicstyle=\small\tt, 
	numbers=left, 
	numberstyle=\scriptsize,
  	stepnumber=1, 
	numbersep=10pt, 
	breaklines=true,
	resetmargins=false,
	xleftmargin=6ex,
	columns=fullflexible}
% #########################################################################################
\chapter{Introduction} \label{sec:Introduction}

A general introduction to the aims of the \OpenADF\ tool and the underlying principles 
was given in an ACM TOMS paper \cite{Utke2008OAM}. 
Because of the ongoing development of the tool a number of changes have occured 
since finalizing this paper. The most significant changes are listed in \refsec{sec:changesSinceTOMS}.
This manual concentrates the technical details of using \OpenADF\ and introduces the 
theoretical principles of automatic automatic differentiation (AD) only 
briefly. For more in-depth discussions the reader is referred to 
\cite{Griewank2008EDP}, the series of AD conference proceedings 
\cite{Griewank1991ADo,Berz1996CDT,Corliss2002ADo,Bucker2005ADA,Bischof2008AiA},
and the AD community's website \url{www.autodiff.org}. \\
\nav{For a quick test with small-scale problems one may proceed directly to \refsec{sec:oneMinute}.} 

% -----------------------------------------------------------------------------------------
\section{Motivation for the \OpenADF\ Design}


One can categorize two user groups of AD tools. 
On one side are casual users 
with small-scale problems applying AD mostly in a black-box fashion 
and demanding minimal user intervention. 
This category also includes users of AD tools in  computational 
frameworks such as NEOS \cite{neosWeb}.
On the other side are experienced AD users aiming for highly efficient 
derivative computations.
Their need for efficiency is dictated by the 
computational complexity of models that easily reaches the limits of  current 
supercomputers. 
In turn this group is willing to accept some limitation in the support of 
language features.

One of the most demanding applications of AD is the computation of gradients for 
data assimilation on large-scale models used in oceanography and climate research. 
This application clearly falls in the category of experienced users.
An evaluation of the available tools revealed some shortcomings from the perspectives 
of the tool users as well as the tool developers and was the rationale for 
designing a new tool with particular emphasis on   
\begin{itemize}
%\itemsep0ex
\item flexibility,
\item the use of open source components, and 
\item modularity.
\end{itemize} 
From  the AD tool  {\em users} point of view there is a substantial need for   
flexibility of AD tools. 
The most demanding  numerical models 
operate at the limit of the computing capacity of state-of-the-art facilities. 
Usually the model code itself is specifically adapted to fit certain 
hardware characteristics. 
Therefore AD tool code generation ideally should be adaptable in a similar fashion. 
Since some of these adaptations may be  too specific for a general-purpose tool,
the AD tool should offer {\em flexibility} at various levels of the 
transformation -- from simple textual preprocessing of the code down to the 
changes to the generic code transformation engine.
This is the rationale for developing an {\em open source} tool where  all
components are accessible  and may be freely modified to suit specific 
needs.  
A {\em modular} tool design with clearly defined interfaces supports such 
user interventions. 
Since this design instigates a staged 
transformation,
each transformation stage presents a opportunity to check and modify the 
results. 

From the AD tool {\em developers} point of view
many AD tools share the same basic algorithms, but
there is a  steep hurdle to establish a transformation environment consisting of
a front-end that turns the textual program into a 
compilerlike internal representation, an engine that allows the 
transformations  of this internal representation, and an unparser that 
turns the transformed internal representation back into source code. 
A {\em modular, open-source} tool facilitating 
the integration of new transformations into an existing environment 
allows for a quick implementation and testing of algorithmic ideas.
Furthermore, a modular design permits the reuse of transformation algorithms 
across multiple target languages, provided the parsing front-ends can translate to and from the 
common internal representation.

These considerations motivated the 
Adjoint Compiler Technology \& Standards \cite{actsWeb} project, a research and 
development collaboration of MIT, Argonne National Laboratory, 
The University of Chicago, and Rice University. \OpenADF\ is one of its major results.

% -----------------------------------------------------------------------------------------
\section{Overview} \label{sec:overview}
\OpenADF \cite{openadWeb}
is the Fortran incarnation of the AD framework \OpenAD.
The C/C++ oriented tool ADIC v2.0 \cite{adicWeb}
is based on the same framework but is 
not subject of this article.
\begin{figure}
  \centering\includegraphics[width=.5\textwidth]{overview}
  \caption{\OpenADF\ components and tool chain} \label{fig:overview}
\end{figure}
\OpenADF\ has  a modular design. 
The collaboration  of the \OpenADF\ components is illustrated in 
\reffig{fig:overview}.
Our input is some numerical model given as a Fortran program 
$\bmf$.
The \OpenSixtyFour\cite{open64Web}
front-end performs a lexical, 
syntactic, and semantic analysis and produces an 
intermediate representation of $\bmf$, here denoted by $\bmf_{\whirl}$, 
in the so-called \whirl\ format.
\OpenAnalysis\ is used to build call and control flow graphs and  perform 
code analyses such as alias, activity, side-effect analysis.
This information is used by 
\whirlToxaif\ to construct a representation of the numerical core of $\bmf$ in
\xaif\ format shown as $\bmf_{xaif}$.  
A differentiated version of $\bmf_{xaif}$ is derived by an 
algorithm that is implemented in \xaifBooster\ and is again represented 
\xaif\ as $\bmfp_{xaif}$.
The information in $\bmfp_{xaif}$ and the original $\bmf_{\whirl}$ are used by 
\xaifTowhirl\ to construct a 
\whirl\ representation $\bmfp_{\whirl}$ of the differentiated code. 
The unparser of 
\OpenSixtyFour\ transforms $\bmfp_{\whirl}$ into Fortran90, thus completing
the semantic transformation of a program $\bmf$ into
a differentiated program $\bmfp$.
The gray shaded area encloses the language specific front-end that can potentially
be replaced by front-ends for languages other than Fortran. 
For instance, the new version of ADIC \cite{HoNo01} couples a C/C++ 
front-end 
based on the EDG parser \cite{edgWeb} and uses ROSE in combination with SAGE~3 \cite{roseWeb} 
as internal representation in combination with language independent components of \OpenAD.

In \refsec{sec:ADIntro} we discuss the basic concepts of AD as relevant for 
the description of \OpenAD, \refsec{sec:openadfcomponents} discusses the components 
that make up \OpenADF, and \refsec{sec:Usage} details the usage of the tool. 
Two applications further illustrate the tool usage in \refsec{sec:application} and 
we conclude with a section on future developments.

% -----------------------------------------------------------------------------------------
\section{A One-Minute Example} \label{sec:oneMinute}

This section provides a quick illustration of the tool without going into any detail of 
the inner workings. It may be useful to run the examples as a sanity test. \\
\nav{Users familiar with source transformation AD tools may want to skip this section and proceed  to \refsec{sec:deciding}.}\\
To obtain the source code for the examples in this section please refer to \refsec{sec:compilingManual}. 
To run the examples one needs to install \OpenADF\ following the instructions in \refsec{sec:dab}.
We assume a simple routine, see \reffig{fig:OneMinute} (left), computing $y=f(x)=\tan(x)$ implemented by \lstinline{head}.
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran]{Examples/OneMinute/head.f90}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran]{Examples/OneMinute/head.prepped.f90}
\end{minipage}
\caption{Simple example code (left, see file 
\lstinline{$OPENADROOT/Examples/OneMinute/head.f90}), %$
prepared for differentiation (right, see file 
\lstinline{$OPENADROOT/Examples/OneMinute/head.prepped.f90})}%$
\label{fig:OneMinute}
\end{figure}
We need to prepare the code for the activity analysis by specifying the independent variables
(here \lstinline{x}) and the dependent variables 
(here \lstinline{y}) shown in lines 4 and 6 of \reffig{fig:OneMinute} (right).
In the following we assume the \OpenADF\ environment has been set up as 
described in \refsec{sec:env}.

% .........................................................................................
\subsection{Forward Mode}\label{sec:forwardMode}
For this simple example we can use the following wrapper script.\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/bin/openad}\\[1ex] %$
The environment setup adds this directory to the \lstinline{PATH}.
All script options are shown when it is invoked with the \lstinline{-h} flag. 
It provides a simple recipe for the AD transformations that we can use in 
a straightforward case like this by calling \\[1ex]
\hspace*{.3cm}\lstinline{cd $OPENDADROOT/Examples/OneMinute}\\ %$
\hspace*{.3cm}\lstinline{openad -c -m f head.prepped.f90}\\[1ex]
to generate a code version for forward mode. The transformation is 
selected  by the flag \lstinline{-m f}.
The script produces progress progress messages 
like the ones shown in \reffig{fig:oneMinuteStatusOutput}.
\begin{figure}
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{oneMinuteStatusOutput.txt}
\end{boxedminipage}
\caption{Progress messages from \lstinline{openad} for forward mode.}\label{fig:oneMinuteStatusOutput}
\end{figure}
The resulting Fortran output is written to a file called\\[1ex]
\hspace*{.3cm}\lstinline{$OPENDADROOT/Examples/OneMinute/head.prepped.pre.xb.x2w.w2f.post.f90}\\[1ex] %$
and its contents is shown in \reffig{fig:OneMinuteTransformed}. 
\begin{figure}
\lstset{basicstyle=,language={[77]Fortran}}
\small\lstinputlisting[frame=single]{Examples/OneMinute/head.prepped.pre.xb.x2w.w2f.post.f90} %$
\caption{Forward mode transformed code for \reffig{fig:OneMinute} (left)}\label{fig:OneMinuteTransformed}
\end{figure}
The formal parameters \lstinline{x} and \lstinline{y} are active and 
consequently their type is changed. 
Lines 24 and 25 contain the derivative of $\tan(x)$ which is $\tan(x)^2+1$.
Because of potential aliasing between the formal parameters of \lstinline{head} 
a temporary variable \lstinline{OADsym_0} is introduced to hold the result before 
it is assigned to the output's value component \lstinline{y%v}. 
The call to \lstinline{sax} performs the forward propagation operation
$$
\dot{y}=\frac{\partial \tan(x)}{\partial x}\cdot \dot{x} \quad ,
$$ 
see also \refeqn{eqn:bbfm} on pg. \pageref{eqn:bbfm}.
A simple driver that calls the transformed \lstinline{head(x,y)}
is shown in \reffig{fig:OneMinuteDriver}.
\begin{figure}
\begin{minipage}{\linewidth}
\small\lstinputlisting[basicstyle=,language=Fortran,frame=single]{Examples/OneMinute/driver.f90}
\end{minipage}
\caption{Forward mode \lstinline{driver} (see file 
\lstinline{$OPENADROOT/Examples/OneMinute/driver.f90}) %$
for the transformed code  shown in \reffig{fig:OneMinuteTransformed} }\label{fig:OneMinuteDriver}
\end{figure}
It initializes 
\lstinline{x%d}$\equiv\dot{x}\equiv 1$ 
and therefore 
\lstinline{y%d}$\equiv\dot{y}$ 
will contain just that partial derivative.
Aside from running the transformation tool chain the \lstinline{openad} script also 
copies the appropriate run time support files into the working directory. These support 
files need to be compiled and linked with the driver and the transformed code. 
The example includes a \lstinline{Makefile}, see \reffig{fig:OneMinuteMake}, 
\begin{figure}
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{Examples/OneMinute/Makefile}
\end{boxedminipage}
\caption{Portion of \lstinline{$OPENADROOT/Examples/OneMinute/Makefile} %$
needed compile and link the forward mode example using the \lstinline{openad} script}\label{fig:OneMinuteMake}.
\end{figure}
and the entire example can be 
built by executing the following commands. \\[1ex]
\hspace*{.3cm}\lstinline{cd $OPENDADROOT/Examples/OneMinute}\\ %$
\hspace*{.3cm}\lstinline{make}\\[1ex]
This creates an executable called \lstinline{driver}.
The \lstinline{Makefile} tests if \lstinline{F90C} is defined in the environment and 
if not assumes \lstinline{gfortran} is installed and should be used.  
The output generated by running \lstinline{driver} is shown in  \reffig{fig:oneMinuteOutput}.\\[1ex]
\nav{An approach without using the \lstinline{openad} script is explained in \refsec{sec:manualForward}.} 
\begin{figure}
\begin{boxedminipage}{\linewidth}
\small\verbatiminput{oneMinuteOutput.txt}
\end{boxedminipage}
\caption{Output from forward mode \lstinline{driver} shown in \reffig{fig:OneMinuteDriver}.}\label{fig:oneMinuteOutput}
\end{figure}

% .........................................................................................
\subsection{Reverse Mode}\label{sec:reverseMode}
There is a slighty different \lstinline{Makefile} and \lstinline{driver} for 
the reverse mode.
As in \refsec{sec:forwardMode} we can use the \lstinline{openad} script by calling \\[1ex]
\hspace*{.3cm}\lstinline{cd $OPENDADROOT/Examples/OneMinuteReverse}\\ %$
\hspace*{.3cm}\lstinline{openad -c -m rj head.prepped.f90}\\[1ex]
The reverse mode  code generation is triggered by setting the flag \lstinline{-m rj}
where \lstinline{rj} stands for {\em reverse joint} mode, see also \refsec{sec:cgReversal}.
The script produces progress output like the one shown in \reffig{fig:oneMinuteReverseStatusOutput}.
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{oneMinuteReverseStatusOutput.txt}
\end{boxedminipage}
\caption{Progress messages from \lstinline{openad} for reverse mode.}\label{fig:oneMinuteReverseStatusOutput}
\end{figure}
The resulting Fortran output is written to a file called\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/Examples/OneMinuteReverse/head.prepped.pre.xb.x2w.w2f.post.f90}\\[1ex] %$
and sections of it are shown in \reffig{fig:OneMinuteReverseTransformed}. 
\begin{figure}
\lstset{language=[90]Fortran,basicstyle=}
\small\lstinputlisting[frame=single]{oneMinuteReverseTaping.f90}
\small\lstinputlisting[frame=single]{oneMinuteReverseAdjoint.f90}
\caption{Reverse mode transformed code sections for taping (top) and adjoint (bottom) for the code from \reffig{fig:OneMinute} (left)}\label{fig:OneMinuteReverseTransformed}
\end{figure}
In particular in \reffig{fig:OneMinuteReverseTransformed}(top) one can observe 
the writing of the local partial derivative to the tape on line 6 
which subsequently is retrieved in the adjoint sweep shown in \reffig{fig:OneMinuteReverseTransformed}(bottom)
on line 3 and used on line 4. 
The latter represents  the actual propagation operation
$$
\bar{x}+=\frac{\partial \tan(x)}{\partial x}\cdot \bar{y} \quad,
$$ 
see also \refeqn{eqn:bbrm} on pg. \pageref{eqn:bbrm}.
A simple driver that calls the transformed \lstinline{head(x,y)}
is shown in \reffig{fig:OneMinuteReverseDriver}.
\begin{figure}
\begin{minipage}{\linewidth}
\small\lstinputlisting[basicstyle=,language=Fortran,frame=single]{Examples/OneMinuteReverse/driver.f90}
\end{minipage}
\caption{Reverse mode \lstinline{driver} routine for the transformed code  shown in \reffig{fig:OneMinuteReverseTransformed} }\label{fig:OneMinuteReverseDriver}
\end{figure}
Note, that here we initialize \lstinline{y%d}
$\equiv\bar(y)=1.0$ which implies
that \lstinline{x%d}
$\equiv \bar{x}$ holds the value of the partial derivative.
As in \refsec{sec:forwardMode}, the \lstinline{openad} script 
copies the appropriate run time support files into the working directory. These support 
files need to be compiled and linked with the driver and the transformed code. 
The example includes a \lstinline{Makefile} (see \reffig{fig:OneMinuteReverseMake}, 
in addition to testing  if \lstinline{F90C} is defined in the environment 
it also tests for \lstinline{CC} and 
if not assumes \lstinline{gcc} is installed and should be used), 
\begin{figure}
\begin{boxedminipage}{\textwidth}
\scriptsize
\verbatiminput{Examples/OneMinuteReverse/Makefile}
\end{boxedminipage}
\caption{Portion of \lstinline{$OPENADROOT/Examples/OneMinuteReverse/Makefile} %$
needed to compile and link the reverse mode example using the \lstinline{openad} script.}\label{fig:OneMinuteReverseMake}.
\end{figure}
The output generated by the driver is shown in  \reffig{fig:oneMinuteReverseOutput}.
\begin{figure}
\begin{boxedminipage}{\linewidth}
\small\verbatiminput{oneMinuteReverseOutput.txt}
\end{boxedminipage}
\caption{Output from reverse mode \lstinline{driver} shown in \reffig{fig:OneMinuteReverseDriver}.}\label{fig:oneMinuteReverseOutput}
\end{figure}

% -----------------------------------------------------------------------------------------
\section{Deciding on \OpenADF\ Usage Patterns}\label{sec:deciding}

The small example in \refsec{sec:oneMinute} already shows two variants of applying the \OpenADF\ tool. 
In this section we step through a number of decisions that will determine how one might use 
\OpenADF\ for a given application. We will just give a cursory explanation of the 
concepts involved and refer to the detailled explanation in other sections.\\ 
\nav{The following sections may not be very relevant for small-scale applications 
and one may skip 
to \refsec{sec:application} to see if any of the examples discussed there is a good template for 
the application in question.}

% .........................................................................................
\subsection{When is AD via source transformation appropriate?}\label{sec:sourceTransformApprop}
AD via operator overloading is available through various tools such as 
AD02 \cite{ad02}, Rapsodia \cite{rapsodiaWeb}, and Adol-C \cite{adolcWeb} (for C and C++). 
\begin{description}
\item[Language Support]
Because operator overloading is not available within the Fortran standard prior to Fortran90 
there is no alternative for older Fortran programs unless they are migrated to the newer standards.
\item[Type Change]
Another concern is the actual type change from Fortran built-in numerical types to 
the user defined type that triggers the execution of the AD logic. 
As is the case in C++ the typechange affects also formatted I/O operations, 
library calls, memory allocation. Consequently, additional changes other than just a global 
change of declarations may be required to obtain a semantically correct program. 
Fortran lacks a template-like language construct to easily obtain 
a type-changed version of the original Fortran source code while keeping 
the use of built-in types untouched.
One can  workaround this problem  by extensive use of 
the C preprocessor or a source transformation tool to perform the type change. 
\item[Activity Analysis] 
Unless source transformation is used, the type change will generally be applied globally to all 
floating point variables. Source transformation tools like \OpenADF\ are able to identify 
the subset of program variables for which derivative computations have to be performed. 
This is known as {\em activity analysis}, see \refsec{sec:openanalysis}. 
Identifying the active variables and performing the type change only to these variables 
can save a substantial amount of computational overhead.
\item[Reverse Mode]
Operator overloading for reverse mode typically relies on tracing each call  
to an  overloaded operation and saving values required for the adjoint computations.
The size of such naive traces severly limits the complexity of computations
for which an operator overloading based reverse mode is feasible.  
Source transformation tools can use program context information and data flow analysis 
to significantly reduce the memory requirements.      
\item[Derivative Order]
For the computation of higher order derivatives operator overloading is often 
viewed as a reasonable approach because the complexity encapsulated in each operator 
outweighs the overhead implied by making an extra call to the overloaded operator.
Unlike for gradients and Hessians there are no large practical applications where 
conquering the technical difficulties of the reverse mode is justified. 
The first two issues may be tackled by applying a source transformation tool to 
perform a selective and semantically correct type change. 
\end{description}
\OpenADF\ has a type change algorithm encapsulated as one step in its transformation chain, see also \refsec{sec:typechange}.
This transformation step can be adapted to the use of a specific type that has overloaded operators defined, for 
instance as in \cite{rapsodiaWeb}.

% .........................................................................................
\subsection{When should the source code be split?}\label{sec:SplittingSource}
\nav{This and the following section typically apply only to models with a large code base.
For small models one can proceed to \refsec{sec:reverseInsteadOfForward}.}\\[1ex] 
Splitting the source is an option to be considered for numerical models that have 
large codes base and have extensive debugging, I/O, monitoring, communication and other 
non-numerical logic. 
The source transformation use data dependency information in the creation of the derivative 
code. The built-in analysis has to be conservatively correct and therefore will likely 
have a conservative overestimate, for instance, of the set of active program variables
for which derivative computations have to be generated. 
The use of common buffers, e.g. in communication or I/O logic can significantly increase the 
overestimate. 
Semantically complicated I/O constructs or other logic that 
is not numerical in nature may be something that is not or only incompletely covered by 
the source transformation tool. 
One should keep in mind that for a tool like \OpenADF\ that is funded by research grants, there is 
little academic benefit to be had from covering esoteric language features as opposed to concentrating 
on the efficiency of the code generated for the typical numerical computations. 
Consequently, filtering out logic that is not part of the numerical core not only will 
increase the likelihood that the tool can transform the code but may also  increase the 
efficiency of the generated code by shrinking the conservative overestimates of the code analysis.

Often the natural way of splitting the code is to identify the source files that pertain to 
the  numerical core and transform only the code in these files.  
The analysis then optimistically assumes the calls to the ``external'' methods will not impact the 
relevant data dependencies.          

% .........................................................................................
\subsection{When Should One Use Reverse Mode Instead of Forward Mode?}\label{sec:reverseInsteadOfForward}
The simplest rule of thumb is to use reverse mode when the number $n$ of inputs is significantly larger than the 
number $m$  of outputs as is typically the case with gradients and Hessians. 
Because of the technical hurdles of the reverse mode one should also consider if the model 
has characteristics such as sparsity or  partial separability that would permit using the forward mode 
even for a nominally large number of independents. 
For large scale models one can also consider to separate the computation if the dimension 
of an intermediate interface is significantly smaller or larger than $n$ and $m$ 
and selectively apply forward and reverse mode to the respective parts. For higher order derivative 
computations $n$ is typically low and consequently one will tend toward 
forward mode. While in principle a reverse mode sweep could be injected there too at any order $o$ 
the efficiency improvement remains at $n$ while the memory requirements for the reverse sweep 
grow linearly with $o$.

% .........................................................................................
\subsection{When Should One Use Checkpointing?}\label{sec:Checkpointing}
\nav{This section applies only to reverse mode computations of models with a long runtime or large  
nonlinear parts; otherwise proceed to \refsec{sec:Usage}.}\\[1ex]
The memory requirements for the reverse mode depend on the extent of nonlinearity in the model 
and are roughly proportional to the run time of the numerical core of the model computation.
The memory is used to trace the forward  computation and retain values needed for the computation 
of the adjoints. 
For large computations the memory requirements for the entire forward trace and all needed 
values are prohibitive and the common tradeoff is to restart the forward run from 
some checkpoint and tracing only small sections with manageable memory requirements. 
Various checkpointing schemes have been devised and examples can be found in \refsec{sec:shallow} 
and \refsec{sec:useMake}. 

% .........................................................................................
\subsection{When should {\tt make} rules be used instead of the {\tt openad} script?}\label{sec:useMake}
The \lstinline{openad} script is intended only as wrapper for the transformation tool chain of simple models. 
Complicated models will have a predefined build process using \lstinline{makefile}s and consequently 
it is more appropriate to integrate the stages of the transformation tool chaine explicitly into that
build process. 
This gives access to all the options at each transformation stage and this extra flexibility 
will be needed for large models. An example for the setup with \lstinline{make} is given in \refsec{sec:shallow}.    


% #########################################################################################
\chapter{Usage Details} \label{sec:Usage}
This section will explain the tool usage in detail.  following contains brief instructions how to obtain and use \OpenADF. 
While the principal approach will remain the same, future development may 
introduce slight changes. The reader is encouraged to refer to the 
up to date instructions on the \OpenADF\ website \cite{openadWeb}.

% -----------------------------------------------------------------------------------------
\section{Download and Build}\label{sec:dab}
All components are open source and readily available for download as \lstinline{tar} files
or via version control checkout. 
The website\\[1ex] 
\centerline{\url{www.mcs.anl.gov/openad}}\\[1ex]
provides details on downloading and building the tool chain. 
The build process essentially consists setting up the environment as described in 
\refsec{sec:env} followed invoking\\[1ex]   
\hspace*{.3cm}\lstinline{make} \\[1ex] 

% -----------------------------------------------------------------------------------------
\section{\OpenADF\ Environment}\label{sec:env}
Building and running the \OpenADF\  tool chain as well as optional updates from 
version control repositories requires certain environment variables to be set. 
This is done as follows.
\begin{enumerate}
\item change directory into the \OpenADF\ source tree:\\
\lstinline{cd OpenAD}
\item set the environment 
\begin{itemize}
\item for \lstinline{shell}/\lstinline{ksh}/\lstinline{bash} users with\\
\lstinline{source ./setenv.sh}
\item for \lstinline{csh}/\lstinline{tcsh} users with\\
\lstinline{source ./setenv.csh}
\end{itemize}
\end{enumerate}
From now on we assume the environment variables have been set and we will refer 
to them as needed.  

% -----------------------------------------------------------------------------------------
\section{Code Preparation with Pragmas (incompl.)} \label{sec:pragmas}

The tool chain recognizes pragmas of the format\\[1ex]
\hspace*{.3cm}\lstinline{$openad }{\tt\em <pragma argument>}\\[1ex] %$
and the specific {\tt\em <pragma argument>} options are listed below.  
\begin{description} 
\item[\underline{\tt independent({\em <variable name>})}] 
At least one of these pragmas is required in the source 
code to be transformed to identify program variables that are considered independent. 
The pragma is used to initialize the activity analysis (see also \refsec{sec:openanalysis}).
The {\em <variable name>} must be a program variable visible in the context in which the pragma is placed.
The front-end and the subsequent tool chain components will parse {\em <variable name>} as a properly 
scoped variable. Index expressions for {\em <variable name>} such as \lstinline{X[2]} are currently not meaningful
for the activity analysis. 
An example is shown in \reffig{fig:OneMinute}(right).
\item[\underline{\tt dependent({\em <variable name>})}] 
At least one of these pragmas is required in the source 
code to be transformed to identify program variables that are considered dependent.
The pragma functions similarly to the above mentioned \lstinline{independent} pragma. 
An example is shown in \reffig{fig:OneMinute}(right).
\item[\underline{\tt xxx template {\em <template file>}}] 
This is an optional pragma.
The postprocessor will recognize 
the procedure in which the pragma occurs (or which immediately follows) as the target to which 
the template should be applied, see also \refsec{sec:PostProcessor}.
The {\em <template file>} needs to be a file either with an absolute path or a 
path relative to the working directory from which the postprocesor is invoked. 
The tool chain has to  parse and pass through the pragma to the postprocessor while retaining the pragma location.
Note that currently the Open64 front-end will within a module \lstinline{contains} block move all such pragmas into the 
beginning of the \lstinline{contains} block and therefore placing the pragma {\em inside} the procedure 
to which it should be applied.
\item[\underline{\tt xxx simple loop}]
This is an optional pragma. 
The transformation recognizes the loop immediately following this declaration and all 
loops nested within as {\em simple loops}, see also \refsec{sec:cfReversal}.
\end{description}

% -----------------------------------------------------------------------------------------
\section{Running the tool chain with the {\tt openad} script}\label{sec:script}
\nav{This section applies only to very simple models. For reasonably complicated computations proceed to \refsec{sec:manualToolChain}.}\\[1ex]
The components of \OpenADF\ transform the code in a predetermined sequence of steps.
Depending on the particular problem there are certain variations to the tool chain execution 
that achieve a better performance of the generated code. 
The most common setups are encapsulated in the Python script \lstinline{$OPENADROOT/bin/openad}. %$. 
The script is part of the skeleton environment that is used to download and build \OpenADF\  
and relies on the same environment setup that also puts the script into the \lstinline{PATH}.
Therefore user starts with steps 1 and 2 from \refsec{sec:dab}. 
Invoking the script with the \lstinline{-h} option displays the following command-line options. \\[1ex]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{openadScriptOptions.txt}
\end{boxedminipage}\\[1ex]
The most important of these options is the mode specification.
The default is the forward (or tangent-linear) mode, which is described in \refsec{sec:BBPreacc}.
The reverse (or adjoint) mode is described in \refsec{sec:BBRev};
the ``split'' and ``joint'' variants refer to two different schemes for call graph reversal (see \refsec{sec:cgReversal}).

As an example, assume we wish to create a tangent-linear version of a code in a file named \lstinline{head.f}.
Invoking the command \lstinline{openad head.f} will create the transformed file \lstinline{head.pre.xb.x2w.w2f.post.f},
where the following messages appear as output during the transformation process. \\[1ex]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{openadScriptOutput.txt}
\end{boxedminipage}\\[1ex]
The script also links (or copies with \lstinline{-c}) a simple version of the necessary support files. 
As with the tool chain itself, a computationally complex application will likely want to adapt the support 
files. 
For larger projects it is obviously appropriate to customize the sequence 
by adding the steps outlined in \refsec{sec:manualToolChain} to a \lstinline{Makefile}. 
The steps performed by the \lstinline{openad} script can serve as an initial guideline for 
the manual invocations. The script dumps the commands without executing them when the \lstinline{-n} 
flag is passed. For the above example the output is shown in \reffig{fig:openadScriptNoAction}.
%\begin{landscape}
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{openadScriptNoAction.txt}
\end{boxedminipage}
\caption{Actions to be performed for the default invocation of the \lstinline{openad} script; we folded long lines.}\label{fig:openadScriptNoAction}
\end{figure}
%\end{landscape}
 
% -----------------------------------------------------------------------------------------
\section{Explicitly invoking the tool chain elements}\label{sec:manualToolChain}
As explained in \refsec{sec:script}, 
the steps performed by the \lstinline{openad} script can serve as an initial guideline for 
the manual invocation of the tool chain components.
Rather than an abstract explanation of the steps we will just show the explicit \lstinline{make} 
rules for the examples in \refsecs{sec:forwardMode}{sec:reverseMode} where we have a prepared 
source file named \lstinline{head.prepped.f90}.
% .........................................................................................
\subsection{Forward Mode}\label{sec:manualForward} 
For forward mode the rules are shown in \reffig{fig:makeForward}.
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{Examples/OneMinute/MakeExplRules.inc}
\end{boxedminipage}
\caption{Contents of \lstinline{$OPENADROOT/Examples/OneMinute/MakeExplRules.inc} %$
included in the example's \lstinline{Makefile} providing explicit rules to replace the 
actions of the \lstinline{openad} script for forward mode.}\label{fig:makeForward}
\end{figure}
By changing directory to \lstinline{$OPENADROOT/Examples/OneMinute} %$
and invoking \\[1ex]
\hspace*{.3cm}\lstinline{make driverE}\\[1ex] 
one triggers the explicit rules shown in \reffig{fig:makeForward} and the output 
including compile and link steps will look like the output shown in \reffig{fig:makeForwardOut} and 
among various extra compiler invocation one will recognize the steps listed in \reffig{fig:openadScriptNoAction}.
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{oneMinuteExplOutput.txt}
\end{boxedminipage}
\caption{Output of invoking \lstinline{make driverE} in \lstinline{$OPENADROOT/Examples/OneMinute} %$
.}\label{fig:makeForwardOut}
\end{figure}

Regarding the individual steps, details may be found in the following references.
\begin{enumerate}
\item {\bf Canonicalization:} The optional canonicalization step not considered in the rules in \reffig{fig:makeForward} is discussed in \refsec{sec:Canonicalization}.
\item {\bf Parsing:} The input source is parsed by the Open64 front-end, see also \refsec{sec:open64FeBe} and 
one obtains a binary file with a \lstinline{.B} extension contain the representation in \lstinline{whirl}.
\item {\bf Translating to XAIF:} The \lstinline{whirl} is analyzed and the results are 
translated into \xaif, see also \refsec{sec:wtxxtw}.
\item {\bf Transforming the XAIF:} The \xaif\ representation is transformed by 
the tangent linear transformation algorithm. The driver for the transformation is located at \\[1ex]
\hspace*{.3cm}\lstinline{$XAIFBOOSTERROOT/xaifBooster/algorithms/BasicBlockPreaccumulation/driver/oadDriver} \\[1ex]%$
see also \refsec{sec:BBPreacc}.
\item {\bf Back - translating the transformed XAIF:} From the transformed \xaif\ a corresponding transformed \lstinline{whirl} 
representation is created, see also \refsec{sec:wtxxtw}. 
\item {\bf Unparsing to transformed Fortran:} From the transformed \lstinline{whirl} we unparse 
to Fortran using the back-end uparser provided by Open64, see also \refsec{sec:open64FeBe}. 
\item {\bf Post processing:} Various constructs that are ancillary to the transformation, 
such as the actual name of the value and the derivative components are done at this stage, 
see also \refsec{sec:PostProcessor}. 
{\bf Note} the command-line flag \lstinline{-f} passed to the post processor to indicate forward mode. 
This flag is required to be consistent with the chosen transformation.
\item {\bf Compiling/Linking:} The transformed sources, the driver and the runtime support files need to be compiled and linked. This is briefly discussed in \refsec{sec:forwardMode} but see also \refsec{sec:compLink}.
\end{enumerate}

% .........................................................................................
\subsection{Reverse Mode}\label{sec:manualReverse} 
\nav{This section follows the same model as \refsec{sec:manualForward}, only for reverse mode. A more 
elaborate reverse mode example can be found in \refsec{sec:shallow} and the experienced user 
may want to jump to that example.}\\[1ex]
For reverse mode the rules are shown in \reffig{fig:makeReverse}.
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{Examples/OneMinuteReverse/MakeExplRules.inc}
\end{boxedminipage}
\caption{Contents of \lstinline{$OPENADROOT/Examples/OneMinuteReverse/MakeExplRules.inc} %$
included in the example's \lstinline{Makefile} providing explicit rules to replace the 
actions of the \lstinline{openad} script for reverse mode.}\label{fig:makeReverse}
\end{figure}
\begin{figure}
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{oneMinuteReverseExplOutput.txt}
\end{boxedminipage}
\caption{Output of invoking \lstinline{make driverE} in \lstinline{$OPENADROOT/Examples/OneMinuteReverse} %$
; we folded long lines.}\label{fig:makeReverseOut}
\end{figure}
By changing directory to \lstinline{$OPENADROOT/Examples/OneMinuteReverse} %$
and invoking \\[1ex]
\hspace*{.3cm}\lstinline{make driverE}\\[1ex] 
one triggers the explicit rules shown in \reffig{fig:makeReverse} and the output 
including compile and link steps will look like the output shown in \reffig{fig:makeReverseOut} and 
among various extra compiler invocation one will recognize the steps listed in \reffig{fig:openadScriptNoAction}.

Regarding the individual steps, details may be found in the same references given in \refsec{sec:manualForward}.
The following differences are noteworthy.
\begin{enumerate}
\item[4.]{\bf Transforming the XAIF:} The \xaif\ representation is transformed by 
the adjoint transformation algorithm. The driver for the transformation is located at\\[1ex] 
\hspace*{.3cm}\lstinline{$XAIFBOOSTERROOT/xaifBooster/algorithms/BasicBlockPreaccumulationReverse/driver/oadDriver} \\[1ex]%$
see also \refsec{sec:BBRev}.
\item[7.] {\bf Post processing:} Various constructs that are ancillary to the transformation, 
such as the actual name of the value and the derivative components are done at this stage, 
see also \refsec{sec:PostProcessor}. 
{\bf Note} that unlike in forward mode the command-line flag \lstinline{-f} is not passed to 
the post processor.
\item[8.] {\bf Compiling/Linking:} There are additional runtime support files need to be compiled and linked 
beyond the set of files for forward mode. 
This is briefly discussed in \refsec{sec:reverseMode} but see also \refsec{sec:compLink}.
\end{enumerate}

% -----------------------------------------------------------------------------------------
\section{Compiling and Linking}\label{sec:compLink}
Examples for compiling and linking the transformed source code can be found in \refsec{sec:oneMinute} and 
\refsec{sec:application}.
Compared to the original model build process the following changes have to be accomodated.
\begin{itemize}
\item To facilitate the AD code analysis and comprehensive transformation 
one has to extract the numerical core into a single file, transform that file and reintegrate 
the transformed source into the build process. 
\item At various stages in the tool chain temporary variables may be introduced and one 
has to be aware of assumptions on the default precision of variables, typically specified during the 
compile step with flags such as \lstinline{-r8} or \lstinline{-i4}. The individual 
\lstinline{make} rules mentioned in \refsecs{sec:manualForward}{sec:manualReverse} 
may have to be adjusted accordingly.
\item There are simple implementations for runtime support files. These simple implementations 
for checkpointing and taping etc. are properly working but may not be the most efficient solution 
for a given application or hardware.  
Consequently, one should consider modifying or reimplementing the runtime support files for 
these aspects.
\end{itemize}
% .........................................................................................
\subsection{Runtime Support Files}  
All support files discussed in this section can be found in the subdirectories under  
\\[1ex] 
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport}\\[1ex] %$
and are the source for the examples used in this Manual.

\subsubsection{Front-End Definitions}
All Fortran produced by \lstinline{whirl2f}, see \refsec{sec:open64FeBe}, needs 
definitions for values supplied as \lstinline{kind} parameters. 
These values have standard names within the \lstinline{whirl2f}-generated code. 
The definitions can be found in \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/all/w2f__types.f90}\\[1ex] %$
Modifications to this file should be done judiciously to avoid cases where identical 
\lstinline{kind} values lead to duplicate definitions of module routines for 
the OpenAD active type that differ 
only by that kind value.

\subsubsection{Active Type}\label{sec:activeTypeDefs}
The active type definitions supplied here cover simple examples of active types. 
They can easily be extended for other experiments, e.g. an on-demand  allocation of 
derivative data at runtime, runtime activity flags etc. 
The definitions cover the data type, conversion routines from active to passive, 
and propagation operations.
\begin{itemize}
\item conversion routines between active and passive data overloaded as module procedures for various  precisions and shapes with the following variations.
\begin{center}
\tt 
convert\_[d|r|a][0-7]\_[d|r|a][0-7](convertTo, convertFrom)
\end{center}
\item propagation routines overloaded as module procedures for various precisions and shapes listed in \reffig{fig:runtimeActive}
\end{itemize}
In the above we abbreviate \\[1ex]
\hspace*{.3cm}
\begin{tabular}{c|l}
\tt i & integer (4 byte) \\ 
\tt l & inetger (8 byte) \\ 
\tt r & float (4 btye) \\ 
\tt d & float (8 byte) \\ 
\tt a & active type \\
\end{tabular}\\
and the following digit $\in [0-7]$ indicates the respective shape.
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\scriptsize\lstinputlisting[frame=single,lastline=12]{rtPropagationRoutines.txt}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\scriptsize\lstinputlisting[frame=single,firstline=13]{rtPropagationRoutines.txt}
\end{minipage}
\caption{Propagation routines extracted from \lstinline{$OPENADROOT/runTimeSupport/scalar/OAD_active.f90} %$
}\label{fig:runtimeActive}	
\end{figure}

\paragraph{Scalar}
An active type for propagation of scalar derivative components is defined in\footnote{
This file is created from \lstinline{$OPENADROOT/runTimeSupport/genBase/OAD_active.F90} %$  
by preprocessing.
} \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/scalar/OAD_active.f90}%$
\paragraph{Vector}
An active type for propagation of a vector of length 
\lstinline{max_deriv_vec_len} of derivative components is defined in\footnotemark[\value{footnote}] \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/vector/OAD_active.f90}\\[1ex] %$
For the sake of simplicity with the demonstration examples 
we have here hard coded the value of \lstinline{max_deriv_vec_len}.  
This value should be adjusted for a given application context either to the number of independent 
variables or a suitable slice size when repeated computation over slices (aka ``strip mining'') 
is to be done.\\
This file is created from \lstinline{$OPENADROOT/runTimeSupport/genBase/OAD_active.F90} %$  
by preprocessing.

\subsubsection{Taping}
A simple implementation for  tape storage can be found in \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/OAD_tape.f90}\\[1ex] %$
which goes together with the subroutines defined in \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/ad_inline.f}\\[1ex] %$
which are inlined by the post processor, see \refsec{sec:PostProcessor}.
For dynamically allocated taping space see the respective files in the \lstinline{cpToFile}
subdirectory.

\subsubsection{Reversal State}
A module containing global reversal scheme state definitions defined in  \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/OAD_rev.f90}\\[1ex] %$
The split and joint reversal schemes using the state are enabled via the templates \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/ad_template.joint.f}\\[1ex] %$
and\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/ad_template.split.f}\\[1ex] %$
respectively.

\subsubsection{Checkpointing (incompl.)}

checkpointing (only  for adjoint models, see \lstinline{runTimeSupport/simple/OpenAD_checkpoints.f90})

\subsubsection{PostProcessor - Inlining (incompl.)}

\subsubsection{PostProcessor - Templates (incompl.)}

\subsubsection{Trace (incompl.)}

% #########################################################################################
\chapter{AD Concepts}\label{sec:ADIntro}

In this section we present the terminology and basic concepts that 
we will refer to throughout this paper. 
A detailed introduction to AD can be found in \cite{Griewank2008EDP}.
The interested reader should also consider the proceedings of AD 
conferences \cite{Griewank1991ADo,Berz1996CDT,Corliss2002ADo,Bucker2005ADA,Bischof2008AiA}.

We present the concepts and resulting transformations 
with respect to the input source code 
in a bottom up fashion.  
We first consider elemental numerical operations, 
then their control flow context within a subroutine and finally the entire program 
consisting of several subroutines in a call graph. 

We view a given numerical model as a 
vector valued function $\bmy=\bmf(\bmx): \R^n\mapsto \R^m$ that is implemented 
as a computer program in a language such as Fortran, C, or C++ and the objective is to  
compute products of Jacobians with see matrices $\bmS$.
\begin{equation}\label{eqn:JacVecProds}
\bmJ \bmS \quad \mbox{and} \quad \bmJ^T \bmS
\end{equation}
% -----------------------------------------------------------------------------------------
\section{Computational Graphs} \label{sec:computationalGraphs}

Without loss of generality we can simply assume that an evaluation of $\bmf(\bmx)$ for  
a specific value of $\bmx$ can be represented by a sequence of 
elemental operations $v_j=\phi_j(\ldots,v_i,\ldots)$. 
The $v_i$ represent the vertices $\in V$ in the corresponding computational 
graph $G=(V,E)$. The edges $(i,j)\in E$ in this graph are the direct dependencies 
$v_i\prec v_j$ implied by the elemental $v_j=\phi_j(\ldots,v_i,\ldots)$.
The elemental operations $\phi$ are differentiable on open subdomains. 
Each edge $(i,j)\in E$ has an attached local partial derivative 
$c_{ji}=\frac{\partial v_j}{\partial v_i}$. 
The central principle of AD is 
the application of the chain rule to the elemental $\phi$, that is 
multiplications and additions of the  $c_{ji}$.  

Like most of the AD literature we follow a specific numbering scheme for the vertices $v_i$.
We presume $q$ intermediate values
$v_j = \phi_j(\ldots,v_i,\ldots), v_j\in Z$
for $j=1,\ldots,q+m$ and $h,i=1-n,\ldots,q,$ $j>h,i$. 
The $n$ {\em independent}
variables $x_1,\ldots,x_n$ correspond to 
$v_{1-n},\ldots,v_0, v_i\in X$. 
We consider the 
computation of derivatives of the {\em dependent} variables 
$y_1,\ldots,y_m$ represented by $m$ variables $v_{q+1},\ldots,v_{q+m}, v_j\in Y$
with respect to the independents. 
The dependency $v_i<v_j$ implies $i<j$. 
The {\em forward mode} of AD propagates directional derivatives
as 
\begin{equation} \label{eqn:fm}
  \dot{v}_j= \sum\limits_i\frac{\partial \phi_j}{\partial v_i}\dot{v}_i 
  \quad \text{for}~~j=1,\ldots,q+m.
\end{equation} 
In {\em reverse mode} we compute adjoints of the arguments of the $\phi_j$
as a function of local partial derivatives and the 
adjoint of the variable on the left-hand side
\begin{equation} \label{eqn:rm}
  \overline{v}_i= \sum\limits_j\frac{\partial \phi_j}{\partial v_i}\overline{v}_j 
  \quad \text{for}~~j=1,\ldots,q+m.
\end{equation} 
In practice, the sum in \refeqn{eqn:rm} is often split into individual increments 
associated with each statement in which $v_i$ occurs as an argument 
$\overline{v}_i=\overline{v}_i+\overline{v}_j * \frac{\partial \phi_j}{\partial v_i}$.

Equations \refeqn{eqn:fm} and \refeqn{eqn:rm} can be used to accumulate 
the (local) Jacobian $\bmJ(G)$
of $G$, see also \refsec{sec:elimMeth}. 
% Obviously \refeqn{eqn:rm}  indicates that the dependencies of $\overline{v}_j$ and 
% $\overline{v}_i$ are reversed to those of $v_j$ and $v_i$. At the same time \refeqn{eqn:rm}
% requires all the values of the $\frac{\partial \phi_j}{\partial v_i}$ in reverse order. To make them 
% available we store them in a stack. In the  AD literature this is commonly called the {\em tape}. 

In a source transformation context we want to generate code for all $\bmf(\bmx)$
in the domain and because the above construction disregards control flow it is 
impractical here. Instead we simply consider the statements contained in a 
\basicblock\  as a section of code below the granularity of control flow and 
construct our computational (sub) graph for a \basicblock.   

% -----------------------------------------------------------------------------------------
\section{Elimination Methods} \label{sec:elimMeth}
Let $\bmf$ represent a single \basicblock\ that is subject to preaccumulation.
For notational simplicity and without loss of generality we assume that the 
dependent variables are mutually independent. 
This situation can always be
reached by introducing auxiliary assignments.
Consider the small example in \reffig{fig:toyBB}.
\begin{figure}[h]
  \begin{center}
    \begin{minipage}{.4\textwidth}
      \fontsize{8pt}{9pt}
      \verbatiminput{code/straightLine.f90}
    \end{minipage}
  \end{center}
  \caption{Example of code contained in a \basicblock}\label{fig:toyBB}
\end{figure}
Reformulating the example in terms of 
results of elemental operations $\phi$ assigned to unique intermediate 
variables $v$ we have 
\begin{equation}\label{eqn:sampleCode}
  \begin{split}
    v_1&=v_{-1}+v_0;~v_2=\sin(v_0);~v_3=v_1+v_2;~v_4=v_1*v_3; \\
    v_5&=\sqrt{v_3};~v_6=\cos(v_4);~v_7=-v_5 \quad .\\
  \end{split}
\end{equation}
In the tool this modified representation is created as part of the linearization transformation, see 
\refsec{sec:linearization}.
In \reffig{fig:elims}~(a) we show the computational graph $G$ for this representation.
\begin{figure}
  \centering\includegraphics[width=.7\textwidth]{elims}
  \caption{
    (a) Computational graph $G$ for \refeqn{eqn:sampleCode}, 
    (b) eliminate vertex 3 from $G$, 
    (c) front eliminate edge $(1,3)$ from $G$, 
    (d) back eliminate edge $(3,4)$ from $G$} 
  \label{fig:elims}
\end{figure}
The edges $(i,j)\in E$ are labeled with partial derivatives
$c_{ji}$, for instance, in the 
example we have $c_{64}=-\sin(v_4)$.
In the tool, this graph is generated as part of the algorithm described in 
\refsec{sec:BBPreacc}.
Jacobian preaccumulation can be interpreted as eliminations in $G$.
The graph-based elimination steps are categorized in vertex, edge, and face 
eliminations. 
In $G$ a vertex $j \in V$ is eliminated by connecting its predecessors with
its successors \cite{Griewank1991OtC}.
An edge $(i,k)$ with
$i \prec j$ and $j \prec k$ is labeled with
$c_{ki}+c_{kj} \cdot c_{ji}$ if it existed before the elimination of $j.$
We say that {\em absorption} takes place.
Otherwise, $(i,k)$ is generated as {\em fill-in} and labeled
with $c_{kj} \cdot c_{ji}$
The vertex $j$ is removed from
$G$ together with all incident edges. 
\reffig{fig:elims}~(b) shows the result of eliminating vertex $3$
from the graph in \reffig{fig:elims}~(a).

An edge $(i,j)$ is {\em front eliminated} by connecting $i$ with all successors
of $j$, followed by removing $(i,j)$ \cite{Naumann2002ETf}.
The corresponding structural modifications of the c-graph in
\reffig{fig:elims}~(a) are shown in
\reffig{fig:elims}~(c) for front elimination of $(1,3).$
The new edge labels are given as well.
Edge-front elimination eventually leads to intermediate vertices in $G$
becoming
{\em isolated}; that is, these vertices no longer have predecessors.
Isolated vertices are simply removed from $G$ together
with all incident edges.

Back elimination of an edge
$(i,j) \in E$ results in connecting all predecessors of $i$
with $j$ \cite{Naumann2002ETf}.
The edge $(i,j)$ itself is removed from $G.$
The back elimination of $(3,4)$ from the graph in \reffig{fig:elims}~(a) 
is illustrated in \reffig{fig:elims}~(d). 
Again, vertices can become isolated as a result of edge-back elimination
because they no longer have successors.
Such vertices are removed from $G.$

Numerically the elimination is the application of 
the chain rule, that is, a sequence of {\em fused-multiply-add} (fma) operations
\begin{equation}\label{eqn:fma}
  c_{ki}=c_{ji}*c_{kj}\hspace*{1ex}(+c_{ki}) 
\end{equation}
where the additions in parenthesis take place only  in the case of 
absorption or otherwise fill-in is created 
as described above.

Aside from special cases a single vertex or edge elimination will result in more
than one fma. {\em Face elimination} was introduced 
as the elimination operation with the finest granularity of exactly 
one multiplication\footnote{Additions are not necessarily directly coupled.} 
per elimination step.

Vertex and edge elimination steps have an 
interpretation in terms of vertices and edges
of $G$, whereas face elimination is performed on 
the corresponding directed line graph $\cal G.$
Following \cite{Naumann2004OAo}, we define the directed line graph $\cal G=(V,E)$ 
corresponding to $G=(V,E)$ as follows:
\[
{\cal V}=
\left\{\,\framebox{$i,j$}      :(i,j)\in E \right\} \cup 
\left\{\,\framebox{$\oplus,j$} :v_j  \in X \right\} \cup 
\left\{\,\framebox{$i,\ominus$}:v_i  \in Y \right\}
\] 
and 
\begin{align*}
  {\cal E}
  &=    \left\{\big(\;\framebox{$i,j$}     \,,\framebox{$j,k$}      \;\big): (i,j),(j,k) \in E        \right\} \\
  &\cup \left\{\big(\;\framebox{$\oplus,j$}\,,\framebox{$j,k$}      \;\big): v_j\in X \land (j,k)\in E\right\} \\
  &\cup \left\{\big(\;\framebox{$i,j$}     \,,\framebox{$j,\ominus$}\;\big): v_j\in Y \land (i,j)\in E\right\} 
  \quad . \\
\end{align*}
That is, 
we add a source vertex $\oplus$ and a sink vertex 
$\ominus$ to $G$ connecting all independents to $\oplus$
and all dependents to $\ominus$. $\cal G$ has   
a vertex $ v \in \cal V$ for each edge in the extended $G$, 
and $\cal G$ has an edge $ e \in \cal E$ for each 
pair of adjacent edges in $G$. \reffig{fig:face_elims} gives an 
example of constructing the directed line graph in (b) from the graph in (a) 
which is the graph from \reffig{fig:elims}(a) extended by the source and sink vertex.   
All intermediate vertices $\framebox{$i,j$} \in \cal V$ inherit the labels  
$c_{ji}$. In order to formalize face elimination, it is advantageous to move away
from the double-index notation and use one that is based on a topological
enumeration of the edges in $G.$ Hence, ${\cal G}=({\cal V}, {\cal E})$ 
becomes a DAG with ${\cal V} \subset I\!\!N$ and
${\cal E} \subset I\!\!N \times I\!\!N$ and
certain special properties.
The set of all predecessors of $j \in {\cal V}$ is denoted as $P_j.$ 
Similarly, $S_j$ denotes the set of its successors in $\cal G.$ 
A vertex 
$j \in \cal V$ is called {\em isolated} if either 
$P_j=\emptyset$ or
$S_j=\emptyset.$ 
Face elimination is defined in \cite{Naumann2004OAo}
between two incident intermediate vertices $i$ and $j$ in $\cal G$ as follows:
\begin{enumerate}
\item If there exists a vertex $k \in \cal V$ such that $P_k = P_i$ and
  $S_k = S_j,$ then
  set $c_k = c_k + c_j c_i$ {\em (absorption)};
  else ${\cal V}={\cal V} \cup \{k'\}$ with a new vertex $k'$ such that
  $P_{k'} = P_i$ and $S_{k'} = S_j$
  {\em (fill-in)} and labeled with $c_{k'} = c_j c_i.$
\item Remove $(i,j)$ from $\cal E.$
\item Remove $i \in \cal V$ if it is isolated. Otherwise, if there exists a vertex $i' \in \cal V$ such that
  $P_{i'} = P_i$ and $S_{i'} = S_i,$ then
  \begin{itemize}
  \item set $c_i=c_i + c_{i'}$ {\em (merge)};
  \item remove $i'.$
  \end{itemize}
\item Repeat Step 3 for $j \in \cal V.$
\end{enumerate}
In \reffig{fig:face_elims}~(c) we show the elimination of $(i,j) \in \cal E$,
where $i=\framebox{$1,3$}$ and $j=\framebox{$3,4$}$.

\begin{figure}
  \centering\includegraphics[width=.65\textwidth]{face_elims}
  \caption{
    (a) $G$ extended, 
    (b) $\cal G$ overlaid, 
    (c) face elimination 
  }
  \label{fig:face_elims}
\end{figure}
A complete face elimination sequence $\sigma_f$ yields a tripartite 
directed line graph $\sigma_f({\cal G})$ that can be transformed back into 
the bipartite graph representing the Jacobian $\bmfp$.
We note that any $G$ can be transformed into the 
corresponding $\cal G$ but that a back transformation 
generally is not  possible once face elimination steps have been applied. 
Therefore, face eliminations can generally not precede vertex and edge 
eliminations.
In \OpenAD\ these eliminations are implemented in the algorithms described in 
\refsec{sec:MMTradeOff} and \refsec{sec:angel}.

In a source transformation context of \OpenADF\ the operations \refeqn{eqn:fma} are 
expressed as actual code, the Jacobian accumulation code. For our example code 
from \reffig{fig:toyBB} the code computing 
the local partials in conjunction with the function value 
is shown in 
\reffig{fig:toyAndPartials}.
\footnote{
  For better readability we write the indices of the $c_{ji}$ with commas.
} 
\begin{figure}
  \begin{center}
    \begin{minipage}{.3\linewidth}
      \begin{align*}
        v_1&=v_{-1}+v_0; \\
        v_2&=\sin(v_0); \\
        v_3&=v_1+v_2; \\
        v_4&=v_1*v_3; \\
        v_5&=\sqrt{v_3};\\
        v_6&=\cos(v_4); \\
        v_7&=-v_5;
      \end{align*}
    \end{minipage}
    \begin{minipage}{.3\linewidth}
      \begin{align*}
        c_{1,-1}&=1; \\
        c_{2,0}&=\cos(v_0); \\
        c_{3,1}&=1; \\
        c_{4,1}&=v_3; \\
        c_{5,3}&=(2\sqrt{v_3})^{-1}; \\
        c_{6,4}&=-\sin(v_4); \\
        c_{7,5}&=-1;
      \end{align*}
    \end{minipage}
    \begin{minipage}{.2\linewidth}
      \begin{align*}
        c_{1,0}&=1; \\
        &\\
        c_{3,2}&=1; \\
        c_{4,3}&=v_1; \\
        &\\
        &\\
        &
      \end{align*}
    \end{minipage}
  \end{center}	
  \caption{Pseudo code for \refeqn{eqn:sampleCode} and the computation of the $c_{ji}$}\label{fig:toyAndPartials}
\end{figure}
In \OpenADF\ the operations in \reffig{fig:toyAndPartials} are generated by the 
transformation algorithm discussed in \refsec{sec:linearization}.
The operations induced by the eliminations on the graph can 
be expressed in terms of the auxiliary variables $c_{ji}$.
For our example, a forward vertex elimination in the order  (1,2,3,4,5) 
in $G$ (\reffig{fig:elims}), leads to the
following Jacobian accumulation code.
\begin{figure}[h]
  % \begin{minipage}{\linewidth}
  %   \begin{align*}
  %     1:\quad  &c_{3,-1}=c_{3,1} * c_{1,-1};~c_{3,0}=c_{3,1} * c_{1,0};~c_{4,-1}=c_{4,1} * c_{1,-1};~c_{4,0}=c_{4,1} * c_{1,0}; \\
  %     2:\quad  &c_{3,0}=c_{3,2} * c_{2,0}+c_{3,0}; \\
  %     3:\quad  &c_{4,-1}=c_{4,3} * c_{3,-1}+c_{4,-1};~c_{4,0}=c_{4,3} * c_{3,0}+c_{4,0};~c_{5,-1}=c_{5,3} * c_{3,-1}; \\
  %     &c_{5,0}=c_{5,3} * c_{3,0}; \\
  %     4:\quad  &c_{6,-1}=c_{6,4} * c_{4,-1};~c_{6,0}=c_{6,4} * c_{4,0}; \\
  %     5:\quad  &c_{7,-1}=c_{7,5} * c_{5,-1};~c_{7,0}=c_{7,5} * c_{5,0} \quad .
  %   \end{align*}
  % \end{minipage}
  \begin{tabular}{l@{\hspace{1ex}}r@{\hspace{0.1ex}}l@{\hspace{1ex}}l@{\hspace{1ex}}l}
    1: &$c_{3,-1}$&$=c_{3,1} * c_{1,-1};         $&$c_{3,0}=c_{3,1} * c_{1,0};        $&$c_{4,-1}=c_{4,1} * c_{1,-1};$\\
    &$c_{4,0} $&$=c_{4,1} * c_{1,0};          $&                                    &                              \\
    2: &$c_{3,0} $&$=c_{3,2} * c_{2,0}+c_{3,0};  $&                                    &                              \\
    3: &$c_{4,-1}$&$=c_{4,3} * c_{3,-1}+c_{4,-1};$&$c_{4,0}=c_{4,3} * c_{3,0}+c_{4,0};$&$c_{5,-1}=c_{5,3} * c_{3,-1};$\\
    &$c_{5,0} $&$=c_{5,3} * c_{3,0};          $&                                    &                              \\
    4: &$c_{6,-1}$&$=c_{6,4} * c_{4,-1};         $&$c_{6,0}=c_{6,4} * c_{4,0};        $&                              \\
    5: &$c_{7,-1}$&$=c_{7,5} * c_{5,-1};         $&$c_{7,0}=c_{7,5} * c_{5,0};        $&            
  \end{tabular}
  \caption{Pseudo code for vertex eliminations for \refeqn{eqn:sampleCode}}\label{fig:toyAccumulation}
\end{figure}
In the tool the operations shown in \reffig{fig:toyAccumulation} are generated by the 
transformation algorithm discussed in \refsec{sec:BBPreacc}. 

% -----------------------------------------------------------------------------------------
\section{Control Flow Reversal} \label{sec:cfReversal}
Because the code for a $\bmf$ generally contains control flow constructs there is no 
single  computational graph 
$G$ that represents the computation of $\bmf$ for all possible values of $\bmx$.
We explained in \refsec{sec:computationalGraphs} that \OpenADF\ considers subgraphs constructed 
from the contents of a \basicblock.
In the example shown in \reffig{fig:toy} we put the \basicblock\ code shown in 
\reffig{fig:toyBB} into a control flow context, see lines 06--09.
\begin{figure}
  \begin{center}
    \begin{minipage}{.5\textwidth}
      \begin{tabbing}
        \hspace{.6cm}{\footnotesize \bf 00}\hspace{.5cm} \lstinline{y(k) = sin(x(1)*x(2))} \\
        \hspace{.6cm}{\footnotesize \bf 01}\hspace{.5cm} \lstinline{k    = k+1} \\
        \hspace{.6cm}{\footnotesize \bf 02}\hspace{.5cm} \lstinline{if} \=\lstinline{(mod(k,2) .eq. 1) then } \\
        \hspace{.6cm}{\footnotesize \bf 03}\hspace{.5cm} \>\lstinline{y(k) = 2*y(k-1)}  \\
        \hspace{.6cm}{\footnotesize \bf 04}\hspace{.5cm} \lstinline{else } \\
        \hspace{.6cm}{\footnotesize \bf 05}\hspace{.5cm} \>\lstinline{do} \=\lstinline{i=1,k } \\
        \hspace{.6cm}{\footnotesize \bf 06}\hspace{.5cm} \>\>\lstinline{t1   = x(1)+x(2) } \\
        \hspace{.6cm}{\footnotesize \bf 07}\hspace{.5cm} \>\>\lstinline{t2   = t1+sin(x(1)) } \\
        \hspace{.6cm}{\footnotesize \bf 08}\hspace{.5cm} \>\>\lstinline{x(1) = cos(t1*t2) } \\
        \hspace{.6cm}{\footnotesize \bf 09}\hspace{.5cm} \>\>\lstinline{x(2) = -sqrt(t2) } \\
        \hspace{.6cm}{\footnotesize \bf 10}\hspace{.5cm} \>\lstinline{end do } \\
        \hspace{.6cm}{\footnotesize \bf 11}\hspace{.5cm} \lstinline{end if } \\
        \hspace{.6cm}{\footnotesize \bf 12}\hspace{.5cm} \lstinline{y(k) = y(k)+x(1)*x(2) } 
      \end{tabbing}
    \end{minipage}
  \end{center}
  \caption{Toy example code with control flow}\label{fig:toy}
\end{figure}
The control flow graph (CFG) \cite{ASU86} resulting from the above code is depicted in 
\reffig{fig:cfg}(a).
The assignment statements are contained in the {\basicblock}s B(2,4,6,9).
For instance, 
the statements from \reffig{fig:toyBB} now  in lines 06--09 form the loop body, \basicblock\ B(6).
As B(6) is executed
\lstinline{k} times it may be worth putting
additional effort into the optimization of the derivative code 
generated for B(6) by optimizing the elimination sequence as illustrated in 
\refsec{sec:elimMeth}.
\begin{figure}[ht]
  \centering
  \begin{tabular}{ccc}
    \includegraphics[width=.25\textwidth]{cfg_ts}
    &
    \includegraphics[width=.25\textwidth]{cfg_tape}
    &
    \includegraphics[width=.25\textwidth]{cfg_adj}
    \\
    \em (a) & \em (b) & \em (c)
  \end{tabular}
  \caption{CFG of \reffig{fig:toy} (a) original, (b) trace generating, (c) reversed}\label{fig:cfg}
\end{figure}
For B(6) the corresponding computational graph $G$  see 
\reffig{fig:elims}(a).  

For a sequence of $l$ {\basicblock}s that are part of 
a path through the CFG for a particular value of $\bmx$ the 
equations~(\ref{eqn:fm}) and (\ref{eqn:rm}) can be generalized as follows:
\begin{equation} \label{eqn:bbfm}
  \dot{\bmy}_j=\bmJ_j \dot{\bmx}_j \quad \text{for}~~j=1,\ldots,l
\end{equation} 
and 
\begin{equation} \label{eqn:bbrm}
  \bar{\bmx}_j=\bmJ^T_j \bar{\bmy}_j \quad \text{for}~~j=l,\ldots,1\quad ,
\end{equation} 
where $\bmx_j = (x^j_i \in V :  i=1,\ldots,n_j)$ and
$\bmy_j = (y^j_i \in V : i=1,\ldots,m_j)$ are the inputs and outputs of the 
{\basicblock}s
respectively. 
In {\em forward mode} a sequence of 
products of the local Jacobians $\bmJ_j$ 
with the directions $\dot{x}_j$ 
are propagated forward in the direction of the flow of control, for 
instance simultaneously to the computation of $\bmf$.
In our example \basicblock\ B(6) is the third \basicblock\ ($j=3$) and we have
$\bmx_3=\bmy_j=($\lstinline{x(1)}$,$\lstinline{x(2)}$)$ and 
consequently have the operations for the Jacobian vector product shown 
in \reffig{fig:toyPreacc}.  
\begin{figure}[h]
  \begin{center}
    \begin{align*}
      t_1&=\dot{\tt x}\mbox{\tt (1)} ; \\
      t_2&=\dot{\tt x}\mbox{\tt (2)}; \\
      \dot{\tt x}\mbox{\tt (1)}&=c_{6,-1}*t_1; \\
      \dot{\tt x}\mbox{\tt (1)}&=\dot{\tt x}\mbox{\tt (1)}+c_{6,0}*t_2; \\
      \dot{\tt x}\mbox{\tt (2)}&=c_{7,-1}*t_1; \\
      \dot{\tt x}\mbox{\tt (2)}&=\dot{\tt x}\mbox{\tt (2)}+c_{7,0}*t_2; 
    \end{align*}
  \end{center}	
  \caption{Pseudo code for $\bmJ_3\dot{\bmx}_3$ for the loop body in \reffig{fig:toy}}\label{fig:toyPreacc}
\end{figure}
Note that the code overwrites \lstinline{x(1)} and \lstinline{x(2)} and therefore 
we have to preserve the original derivatives in temporaries $t_1$ and $t_2$.

In {\em reverse mode} products of the transposed
Jacobians $\bmJ^T_j$ with adjoint vectors $\overline{\bmy}_j$
are propagated reverse to the direction of the flow of control.
The $\bmJ^T_j$ can be computed by augmenting the original code with 
linearization and Jacobian accumulation statements, see \refsec{sec:elimMeth}.
The preaccumulated  $\bmJ^T_j$ are stored during the forward execution
which is commonly called the {\em tape}, see \reffig{fig:toyPreaccRev}(a) for an 
example. They are retrieved from the 
tape for computing \refeqn{eqn:bbrm} during the reverse execution, see \reffig{fig:toyPreaccRev}(b) for 
an example. 
It is always possible to organize the store and retrieve such that the tape can be 
implemented as a stack.
\begin{figure}[h]
  \begin{center}
    \begin{minipage}[b]{.2\linewidth}
      \lstinline{push(}$c_{6,-1}$\lstinline{);}\\
      \lstinline{push(}$c_{6,0}$\lstinline{);}\\
      \lstinline{push(}$c_{7,-1}$\lstinline{);}\\
      \lstinline{push(}$c_{7,0}$\lstinline{);}\\
      \\ \\ \\
      \centerline{(a)}
    \end{minipage}
    \begin{minipage}[b]{.2\linewidth}
      \small
      \begin{align*}
        t_2&={\tt pop()}*\bar{\tt x}\mbox{\tt (2)};\\
        t_1&={\tt pop()}*\bar{\tt x}\mbox{\tt (2)};\\
        t_2&=t_2+{\tt pop()}*\bar{\tt x}\mbox{\tt (1)};\\
        t_1&=t_1+{\tt pop()}*\bar{\tt x}\mbox{\tt (1)};\\
        \bar{\tt x}\mbox{\tt (2)}& =t_2;\\
        \bar{\tt x}\mbox{\tt (1)}& =t_1;
      \end{align*}
      \centerline{(a)}
    \end{minipage}
  \end{center}	
  \caption{Pseudo code for writing the tape (a) and consuming the tape for  $\bmJ_3^T\bar{\bmy}_3$ (b) for  the loop body in \reffig{fig:toy}}\label{fig:toyPreaccRev}
\end{figure}

In order to find the corresponding path to the reversed control flow graph 
we also have to generate a trace which is done with an augmented CFG,
for our toy example see \reffig{fig:cfg}(b).
This augmented CFG  keeps track of which branch was taken and counts how 
often a loop was 
executed.  
This information is pushed on  a stack and popped from that stack during the 
reverse sweep see also \cite{Utke2006ERo}. Because the control flow trace 
adheres to the stack model it often is also considered part of the tape. 
In the example in \reffig{fig:cfg}(b) the extra {\basicblock}s pBT and pBF push 
a boolean (T or F) onto the stack depending on the branch. 
In iLc we initialize a loop counter, increment the loop counter in +Lc, 
and push the final count in pLc. 

\reffig{fig:cfg}(c) shows the reversed CFG for our toy example. 
The parenthesized numbers in the node labels align the 
node transformation to \reffig{fig:cfg}(a). 
The \exit\ node becomes 
the \entry, \Loop\ becomes \EndLoop, \branch\ becomes \EndBranch, and vice versa. 
Each \basicblock\  B is replaced with its reversed version B'.  
Finally, to find the proper path through this reversed CFG we need to retrieve 
the information recorded in  \reffig{fig:cfg}(b). The extra nodes pB and pLc 
pop the branch information and the loop counter respectively.  
We enter the branch and execute the loop as indicated by the recorded information. 
The process of the control flow reversal is described in detail in 
\cite{Utke2006ERo}. 

% -----------------------------------------------------------------------------------------
\section{Call Graph Reversal} \label{sec:cgReversal}

Generally, the computer program 
induces a {\em call graph} (CG) \cite{ASU86}
whose vertices are subroutines and whose edges 
represent calls potentially made during the computation of $\bmy$ for all 
values of $\bmx$ in the domain of $\bmf$.

For a large number of problems it is possible to statically 
predetermine either 
{\em split} or {\em joint} 
reversal \cite{Griewank2008EDP} for any subroutine in the call graph .
These concepts are easier understood with the help of the dynamic call tree,
see also \cite{Naumann2005STf}.
\begin{figure}
  \centering
  \begin{tabular}{p{.5\linewidth}p{.3\linewidth}}
    \begin{minipage}[b]{\linewidth}
      \footnotesize
      \tt subroutine A()\\
      \hspace*{3ex}call B(); call D(); call B();\\
      end subroutine A\\[.2em]
      subroutine B()\\
      \hspace*{3ex}call C()\\
      end subroutine B\\[.2em]
      subroutine C()\\
      \hspace*{3ex}call E()\\
      end subroutine C
    \end{minipage}
    &
    \centering{\includegraphics[height=3.2cm]{edct_ns}}
  \end{tabular}
  \caption{Dynamic call tree of a simple calling hierarchy}
  \label{fig:simple_dct}
\end{figure}
where each vertex represents an actual invocation of a subroutine for a 
given execution of the program, see \reffig{fig:simple_dct} and 
\reftab{tab:leg} for an explanation of the symbols. 
The order of calls is implied by following the edges in left to right order. 
Using split reversal for all subroutines in the  program 
means that first the tape for the entire program is written. Then 
we follow with the reverse steps that read the tape, see \reffig{fig:split}. 

\begin{table}[t]
  \begin{center}
    \begin{tabular}{clcl}
      \includegraphics[width=0.7cm]{box}  
      & 
      \begin{minipage}[b]{.3\linewidth}
        $n$-th invocation
        of subroutine {\tt S}
      \end{minipage} 
      & 
      \includegraphics[width=0.7cm]{call} & 
      \begin{minipage}[b]{.3\linewidth}
        subroutine call\\[-2mm]
      \end{minipage} 
      \\ 
      \includegraphics[width=0.7cm]{rf}  & 
      \begin{minipage}[b]{.3\linewidth}
        run forward \\[-2mm]
      \end{minipage}
      & 
      \includegraphics[width=0.7cm]{order}  & 
      \begin{minipage}[b]{.3\linewidth}
        order of execution \\[-2mm]
      \end{minipage}
      \\
      \includegraphics[width=0.7cm]{sac}  & 
      \begin{minipage}[b]{.3\linewidth}
        store checkpoint \\[-2mm]
      \end{minipage}
      & 
      \includegraphics[width=0.7cm]{rac}  & 
      \begin{minipage}[b]{.3\linewidth}
        restore checkpoint \\[-2mm]
      \end{minipage}
      \\
      \includegraphics[width=0.7cm]{ta}  & 
      \begin{minipage}[b]{.3\linewidth}
        run forward and tape \\[-2mm]
      \end{minipage}
      & 
      \includegraphics[width=0.7cm]{ad}  & 
      \begin{minipage}[b]{.3\linewidth}
        run adjoint \\[-2mm]
      \end{minipage}
      \\
    \end{tabular}
  \end{center}
  \caption{Symbols for call tree reversal}
  \label{tab:leg}
\end{table}

\begin{figure}[t]
  \centerline{\includegraphics[height=3.2cm]{edct_split_ns}}
  \caption{Dynamic call tree for split reversal}
  \label{fig:split}
\end{figure}

\begin{figure}[t]
  \centerline{\includegraphics[height=3.2cm]{edct_joint_ns}}
  \caption{DCT of adjoint obtained by joint reversal mode}
  \label{fig:joint}
\end{figure}

Using joint reversal for all subroutines in a program 
means that the tape, see \refsec{sec:cfReversal} for a each 
subroutine invocation is written immediately before the reverse execution for 
that invocation. In our example this implies that we have to generate 
a tape for \lstinline{C}$^2$ while the caller \lstinline{B}$^2$ is being reversed, 
i.e. this is not the proper context to simply reexecute \lstinline{C}$^2$. 
We can either reexecute the entire program up to the  \lstinline{C}$^2$
call and then start taping, or (preferably) we store the arguments while 
running forward and restore them before starting the taping. 
The ensuing dynamic call tree for our example is 
shown in \reffig{fig:joint}. 
For many applications neither an all split nor all joint reversal
is efficient. Often a mix of split and joint reversals statically  
applied to subtrees of the call tree is suitable.  

% #########################################################################################
\chapter{Components of \OpenADF}\label{sec:openadfcomponents}

\OpenADF\ is built on components that belong to a framework designed
for code transformation of numerical programs.  The components are
tied together either via programmatic interfaces or by communication
using the \xaif\ language. The transformation of the source code follows the
tool chain shown in \reffig{fig:overview}.  
In \refsec{sec:openadcomponents} we describe the language-independent 
components of \OpenAD\ framework and \refsec{sec:fortfe} provides details 
in the Fortran front-end.
The regular setup procedure for \OpenADF, see also \refsec{sec:dab}, 
will retrieve all components into an \lstinline{OpenAD/} directory to which 
we refer from here on.  

% -----------------------------------------------------------------------------------------
\section{Language Independent Components (\OpenAD)}\label{sec:openadcomponents}

The component design of the tool aims for reuse of the different components 
for different types of source transformation of numerical codes, for 
different programming languages in which these tools are written and finally 
also for the reuse of the individual components in different contexts. 
A second, equally important concern is the flexibility of the tool.  
This section covers the language independent components that make up the core \OpenAD\ framework. 

% -----------------------------------------------------------------------------------------
\subsection{Static Code Analyses (\OpenAnalysis)} \label{sec:openanalysis}

The \OpenAnalysis\ toolkit, see \cite{oaWeb}, separates program
analysis from language-specific or front-end specific intermediate
representations.  This separation enables a single implementation of
domain-specific analyses such as activity analysis, to-be-recorded
analysis, and linearity analysis in \OpenADF.  Standard analyses
implemented within \OpenAnalysis\ such as CFG construction, call graph
construction, alias analysis, reaching definitions, ud- and du-chains,
and side-effect analysis are also available via
\OpenADFortTk.

\OpenADFortTk\ interfaces with \OpenAnalysis\ as a producer and a
consumer.  A description of Alias analysis illustrates this
interaction.  \xaif\ requires an alias map data structure, in which
each variable reference is mapped to a set of virtual locations that
it may or must reference.  For example, if a global variable \lstinline{g}
is passed into subroutine \lstinline{foo} through the reference parameter
\lstinline{p}, variable references \lstinline{g} and \lstinline{p} will reference the
same location within the subroutine \lstinline{foo} and therefore be aliases.  
\OpenAnalysis\ determines the aliasing relationships by querying an
abstract interface called the alias IR interface, which is a 
language-independent interface between \OpenAnalysis\ and any
intermediate representation for an imperative programming language.  
An implementation of the alias IR interface for the Fortran~90
intermediate representation is part of
\OpenADFortTk.  The interface includes queries for an iterator over
all the procedures, statements in those procedures, memory references
in each statement, and memory reference expression and location
abstractions that provide further information about memory references
and symbols.  The results of the alias analysis are then provided back
to \OpenADFortTk\ through an alias results interface.

Using language-independent interfaces between \OpenAnalysis\ and the
intermediate representation will enable alias analysis for multiple
language front-ends without requiring \xaif\ to include the union of
all language features that affect aliasing (ie. pointer arithmetic and
casting in C/C++ and equivalence in Fortran~90).  Instead
\OpenAnalysis\ has analysis-specific interfaces for querying
language-specific intermediate representations.

\OpenAnalysis\ also performs activity analysis.  For activity analysis
the independent and dependent variables of interest are communicated
to the front-end through the use of pragmas, see \refsec{sec:open64FeBe}.
The results of the analysis are then encoded by the Fortran~90
front-end into \xaif.  The analysis indicates which variables are
active at any time, which memory references are active, and which
statements are active.

The activity analysis itself is based on the formulation in~\cite{Hascoet2005bra}.
The main difference is that the data-flow framework in \OpenAnalysis\ does not
yet take advantage of the structured data-flow equations.  Activity analysis is
implemented in a context-insensitive, flow-sensitive interprocedural fashion.

All sources for \OpenAnalysis\ can be found under \lstinline{OpenAD/OpenAnalysis/}.

% -----------------------------------------------------------------------------------------
\subsection{Representing the Numerical Core (\xaif)} \label{sec:xaif}

To obtain a language independent representation of programs across multiple 
programming languages one might choose the union of all language features. 
On the other hand one can observe that the majority of differences between 
languages does not lie with the elemental numerical operations that are at the 
heart of AD transformations. This more narrow representation 
is a compromise permitting just enough coverage to achieve language 
independence for the numerical core across languages.
Consequently, certain program features are not represented and have 
to be retained by the language specific front-end to reassemble the 
complete program from the (transformed) numerical core.
Among the generic language features not considered part of the numerical core are: 
\begin{itemize}
  \parskip = -2pt
\item user type definitions and member access, see also \refsec{sec:Canonicalization}
\item pointer arithmetic
\item I/O operations  
\item memory management, see also \refsec{sec:mods}
\item preprocessor directives
\end{itemize}
For a more general discussion regarding this compromise see also \cite{Utke2004SLD}.
It is apparent that certain aspects of the adjoint code such as 
checkpointing, see \refsec{sec:cgReversal}, and taping, see \refsec{sec:cfReversal},
can involve memory allocation and various I/O schemes and therefore 
are not amenable to representation in the \xaif. 
At the same time it is also clear that the way  one has to handle the memory and I/O for 
taping and checkpointing is primarily determined by the problem size at runtime and not
primarily by the code we transform.   
Therefore in \OpenAD\ such transformation results are handled by  specific 
code expansion for subroutine specific templates and inlinable subroutine calls 
in the post processor, see \refsec{sec:PostProcessor}. This not only avoids 
the typically language specific I/O and memory management aspects, it also 
affords additional flexibility.   

The format of choice in \OpenAD\ is an XML-based \cite{xmlWeb} hierarchy of 
directed graphs, referred to as \xaif 
\cite{Hovland2002AXB}. Using XML is motivated by the existence of XML parsers and 
the ability to specify the \xaif\ specific XML contents with a schema which 
the parser can use to validate a given \xaif\ representation. 
The current \xaif\ schema is documented at \cite{xaifweb}.
The basic building blocks are the same data structures commonly found 
in compilers from top down call graph with scopes and symbol tables, 
control flow graphs as call graph vertices, basic blocks  as control flow 
graph vertices, statement lists contained in basic blocks, 
assignments as a statement with expression graphs,  and variable references 
and intrinsic operations as expression graph vertices. 
The role of the respective elements in the \xaif\ schema is fairly self evident. 
Elements are associated by containment. In the graph structures edges 
refer to source and target vertices by vertex ids. 
Variable references contain references to symbols which in turn 
are associated to symbol table elements via a scope and a symbol id. 

An snipppet of the \xaif\ representation of a part of the 
example code  from \reffig{fig:OneMinute}(right) can be found in  
\reffig{fig:wtxxtwXaif}. 
\begin{figure}[h]
\small
\lstset{language=XML,emph={xaif:BasicBlock,xaif:Entry,xaif:Assignment,xaif:AssignmentLHS,xaif:AssignmentRHS,xaif:Intrinsic,xaif:VariableReference,xaif:SymbolReference,xaif:ExpressionEdge,xaif:Exit,xaif:ControlFlowEdge},emphstyle=\bf}
\lstinputlisting[frame=single,firstline=119,lastline=130]{Examples/OneMinute/head.prepped.pre.xaif}
  \caption{Snippet of \xaif\ representation for line 5 of \reffig{fig:OneMinute}(right)}\label{fig:wtxxtwXaif}
\end{figure}
When \lstinline{make} is invoked in \lstinline{$OPENDADROOT/Examples/OneMinute/}%$
the full \xaif\ is written to a file called \lstinline{$OPENDADROOT/Examples/OneMinute/head.prepped.pre.xaif}.%$

Further documentation for individual elements can be found directly in the 
schema annotations. 

The \xaif\ also contains the results of the code analyses provided 
by \OpenAnalysis, see \refsec{sec:openanalysis}. Some are expressed 
either as additional attributes on certain \xaif\ elements, e.g. for activity information. 
Side-effect analysis provides lists of variable references per subroutine, i.e. a call graph vertex element.
DuUd chains are expressed as list of ids found in the assignment \xaif\ element.
Alias information is expressed as set of virtual addresses. 
DuUd chains and alias information is collected in maps indexed by keys associated with the call 
graph. References to individual entries held in these maps are expressed via foreign key 
attributes in the elements. 

The source transformation at the code of \OpenAD\ potentially changes and augments 
all elements of the \xaif. While it would in principle be possible  
to express the result entirely in the plain \xaif\ format we already mentioned the 
code expansion approach. Therefore the transformed \xaif\ adheres to a schema 
that is extended by a construct to represent inlinable subroutine calls and 
a specific list of control flow graphs that the post processor places in predefined 
locations in the subroutine template.    

The \xaif\ schema and examples can be found under \lstinline{OpenAD/xaif/}.

% -----------------------------------------------------------------------------------------
\subsection{Transforming the Numerical Core (\xaifBooster)} \label{sec:xaifBooster}
The transformation engine that differentiates the \xaif\ representation of 
$\bmf$ is called \xaifBooster. It is implemented in C++ based on a 
data structure that represents all information supplied in the \xaif\ input 
together with collection of algorithms that operate on this data structure, modify 
it and produce transformed \xaif\ output as the result. All sources for \xaifBooster\ can be found under \lstinline{OpenAD/xaifBooster/}. The principal setup of the source tree is shown in \reftab{tab:dirStruct}.
\begin{figure}
  \centering \includegraphics[width=.45\textwidth]{irInh}
  \caption{Simplified class inheritance in \xaifBooster} \label{fig:iri}
\end{figure}
The \xaifBooster\ data structure  
closely resembles the information one would find in a 
compiler's high level internal representation. 
the boost graph library \cite{boostWeb}
and the Standard C++ Library\cite{libstdcWeb}.
\reffigBS{fig:iri} and \reffig{fig:irc} show simplified subsets of the classes 
occurring in the \xaifBooster\ data structure in the inheritance 
as well as the composition hierarchy.  
\begin{figure}[htb]
  \centering \includegraphics[width=.45\textwidth]{irComp}
  \caption{Simplified class composition in \xaifBooster} \label{fig:irc}
\end{figure}
A doxygen generated documentation of the entire data structure 
can be found on the \OpenAD\ website \cite{openadWeb}.
The class hierarchy is organized top down with 
a single \lstinline{CallGraph} instance as the top element. 
The top down structure is also imposed on the ownership of dynamically 
allocated elements. 
Wherever possible, the class interfaces encapsulate dynamic 
allocation of members.  
Only in cases of containment of polymorphic elements is explicit dynamic allocation 
outside of the owning class' members appropriate. 
In these cases the container class interface naming and documentation 
indicates the assumption of ownership of 
the dynamically allocated elements being supplied to the container class. 
An example is the graph class \lstinline{Expression} accepting vertex instances that can be 
\lstinline{Constant}, \lstinline{Intrinsic} , etc.

The transformation algorithms are modularized to enable reuse in different 
contexts. 
\begin{figure}
  \centering \includegraphics[width=.45\textwidth]{allAlgs}
  \caption{\xaifBooster\ algorithms} \label{fig:allAlgs}
\end{figure}
\reffig{fig:allAlgs} shows some implemented algorithms with dependencies.
To avoid conflicts the transformation algorithms the data structure representing the input code  
is never directly modified. 
Instead, any data representing modifications or augmentations of the 
original representation element in a class \lstinline{<name>}
are held in algorithm specific instances of class \lstinline{<name>Alg}.
The association is done via mutual references accessible 
through \lstinline{get<name>AlgBase()} and \lstinline{getContaining<name>()} respectively.
The instantiation of the algorithm specific classes follows 
the factory design pattern. The factory instances in turn are controlled 
by a transformation algorithm specific \lstinline{AlgFactoryManager} classes. 
Further details can be found in \cite{Utke2003STI}, however, the code 
code for this mechanism is fairly self-explanatory.  

In the following sections we want to concentrate on the transformation 
the algorithms execute while deferring to the generated code 
documentation for most technical details.

Each algorithm has a driver \lstinline{oadDriver.cpp} (compiled into a binary \lstinline{oadDriver}) 
found in \lstinline{algorithms/<the_algorithm_name>/test/} 
that encapsulates the algorithm 
in a stand-alone binary which provides the functionality described 
in the following 
sections. For details on the invocation and command line options refer to 
\refsec{sec:manualToolChain}.

% -----------------------------------------------------------------------------------------
\subsubsection{Reading and Writing \xaif}\label{sec:readWriteXaif}
Reading and Writing the \xaif\ is part of basic infrastructure
found in the sources in \lstinline{system/}.
Parsing is done through the Xerces C++ XML parser \cite{xercesWeb}
such that the XML element handler implementations, see \lstinline{system/src/XAIFBaseParserHandlers.cpp},
build the \xaifBooster\ data 
structure from the top down. 
As an additional consistency check all components that read \xaif\ data 
have the validation according to the schema enabled. Beyond the schema 
validation these components perform validity checks. Therefore, 
manual modifications of \xaif\ data , while possible, should 
be done judiciously. 

The unparsing of the transformed data structure into \xaif\ is performed 
through a series of that traverses the data structure and the 
respective algorithm specific data. 
For information of the files containing the \xaif\ representation refer to 
\refsec{sec:manualToolChain}.

Aside from the parsing of the actual input \xaif\ there is also the so called 
{\em 
  catalog of inlinable intrinsics
} 
supplied as an XML following a specialized schema in \xaif, see  
\refsec{sec:linearization} and \refsec{sec:wtxxtw}.
There is also a driver at this level found in \lstinline{system/test/t.cpp} used 
to verify reading and writing functionality. It can be used to establish 
that the tool chain preserves the semantics of the original program when 
no transformation is involved. 

% -----------------------------------------------------------------------------------------
\subsubsection{Type Change}\label{sec:typechange}

% -----------------------------------------------------------------------------------------
\subsubsection{Linearization}\label{sec:linearization}

\refsec{sec:ADIntro} explained the computation of 
the local partial derivatives $c_{ji}$ that can be thought of as edge labels 
in the computational graph $G$. 
Per canonicalization (see \refsec{sec:Canonicalization}) 
all elemental $\phi$ 
occur only in the right-hand side of an assignment. 
For each $\phi$ we look up the definition of the respective partials in 
the intrinsics catalog. 
{\color{red} [ not sure  how much detail is necessary ] } 
The partials are defined in terms of positional arguments, see 
\reffig{fig:divExample}. 
\begin{figure}
  \centering \includegraphics[width=5cm]{divIntrinsic}
  \caption{Partial expressions for the division operator} \label{fig:divExample}
\end{figure}

Because of this, 
the right-hand-side expression may have to be split up into 
subexpressions to assign intermediate values to ancillary variables 
that can be referenced in the partial computation, for an example see 
the code shown in \reffig{fig:toyAndPartials}.  
In cases of the left-hand-side variable occurring on the right-hand-side 
(or being may-aliased to a right-hand-side variable, 
see \refsec{sec:openanalysis}) we also require an extra assignment to 
delay the (potential) overwrite until after the partials depending on 
the original variable value have been computed.
The result of the Linearization is a representation for 
code containing the potentially split 
assignments along with assignments for each non-zero edge label $c_{ji}$.
These representations are contained in the \lstinline{xaifBoosterLinearization::AssignmentAlg} instances associated with each assignment in the \xaif.
The generated code after unparsing to Fortran 
is compilable but does by itself not compute useful 
derivative information at the level for the target function $\bmf$. The 
transformation driver is 
used to verify the results of the linearization transformation.

% -----------------------------------------------------------------------------------------
\subsubsection{Basic Block Preaccumulation}\label{sec:BBPreacc}

This transformation generates a code representation that can be used 
to compute derivatives in forward mode. It builds upon the Linearization
done in \refsec{sec:linearization}. 
The first step constructs the 
computational graphs $G$ 
for contiguous 
assignment sequences in a given \basicblock. To ensure semantic 
correctness of the graph being constructed in the presence of 
aliasing it relies on alias analysis and define-use/use-define chains 
supplied by \OpenAnalysis, see \refsec{sec:openanalysis}.
The algorithm itself is described in detail in \cite{Utke2005FBB}.
Because the analysis results supplied by \OpenAnalysis\ are always 
conservatively correct it may not be possible to flatten all 
assignments into a single computational graph. In such cases 
a sequence of graphs is created. Likewise, the occurrence 
of a subroutine call leads to a split in the graph construction. 
In the context of \refsec{sec:ADIntro} one may think of the sets of 
assignments forming each of these graphs as a separate \basicblock. 
The driver for the algorithm allows to disable 
the graph construction across assignments and restrict it to 
single right-hand sides by adding the \lstinline{-S} command 
line flag. 

Based on the constructed $G$ an elimination sequence has to be determined.
To allow a choice for the computation of the elimination sequence 
the code uses the interface coded in \lstinline{algorithms/CrossCountryInterface/}
and by default calls the \angel\ library \cite{angelWeb,Albrecht2003Mth,Naumann2003SAf}.
\angel\ determines an elimination sequence and returns it as 
fused multiply add expressions in terms of the edge references.
There are several heuristics implemented within \angel\ that control 
the selection of elimination steps and thereby the preaccumulation code 
that is generated.  The algorithm code calls a default set of heuristics. 
However, all heuristics use the \lstinline{CrossCountryInterface} and therefore 
different heuristics can be selected with minimal changes in algorithm code.   

The second step in this transformation is the generation of 
preaccumulation code. 
First it  turns the abstract expression graphs returned by \angel\ 
into assignments and resolves the edge references into 
the  labels $c_{ji}$. The resulting code resembles what 
we show in  \reffig{fig:toyAccumulation}. 
Then it generates the code that eventually performs the \saxpy\ 
operations shown in \refeqn{eqn:bbfm}. 
Considering the input and output variables $\bmx_j$ and $\bmy_j$ of a \basicblock\ the code generation 
also ensures proper propagation of $\dot{x}_i^j$ of variables $ x_i^j \in  \bmx_j \cap \bmy_j$ 
by saving the $\dot{x}_i^j$ in temporaries. The example in \reffig{fig:toyPreacc} illustrates this case. 
The detection of the intersection elements relies on the alias analysis provided by 
\OpenAnalysis.
To reduce overhead 
the generated \saxpy\ operations we generate \saxpy\ calls following the 
interface specified in \lstinline{algorithms/DerivativePropagator/} for the following four cases:
\begin{equation}\label{eqn:fourSaxpy}  
  \mbox{(a):}\;\;\dot{y} = \frac{\partial y }{\partial x }\cdot \dot{x},\; 
  \mbox{(b):}\;\;\dot{y} = \frac{\partial y }{\partial x }\cdot \dot{x} + \dot{y},\; 
  \mbox{(c):}\;\;\dot{y} = \dot{x},\;
  \mbox{(d):}\;\;\dot{y} = 0\quad .
\end{equation}	
The generated code is executable and represents an overall forward mode 
according to \refeqn{eqn:bbfm} with \basicblock\-local preaccumulation in 
cross-country fashion. 

% -----------------------------------------------------------------------------------------
\subsubsection{Memory/Operations Tradeoff}\label{sec:MMTradeOff}

This algorithm can be seen as an alternative to the \angel\ library. 
Like \angel\ it uses the \lstinline{CrossCountryInterface}. In its implementation 
it replaces the call to \angel\ with one to its own internal routines that
determine an elimination sequence according to a selectable set of heuristics. 
In difference to the \angel\ heuristics  they 
aim for a tradeoff between the number of operations required to complete an elimination 
sequence on the one hand and the temporal locality of the $c_{ji}$ in memory on the other hand. 
The rationale for these heuristics is the observation that in many modern 
computer architectures the performance is memory bound, i.e. a few additional 
operations can easily be absorbed if we keep all the necessary data in cache. 
All heuristics take as an input a set $\Theta \neq \emptyset $ of target elements, that is 
a set of vertices or edges from $G$, or faces from $\cal G$. 
The heuristic selects a nonempty subset $\Theta'\subseteq \Theta $ from this set. 
In order to determine a single elimination target a sequence of heuristics may be applied 
that successively shrink the target set concluding with a tie breaker such as 
selecting the next target that would be eliminated in forward or reverse mode. 
\reftab{tab:memOpsHeur} describes the selection criterion of a heuristics with 
respect to an elimination technique.  If the selection criterion is not met 
by any target in $\Theta$, then $\Theta'=\Theta$. 
\begin{table}[htb]
  \begin{tabular}{|l|c|c|c|}\hline
    & {\tt VERTEX} & {\tt EDGE} & {\tt FACE} 
    \\\hline %---------------------------------------
    {\tt SIBLING} 
    &
    \begin{minipage}{.4\linewidth}
      \footnotesize
      select vertices that share at least one predecessor
      and successor with the most recently eliminated vertex.
    \end{minipage}
    & N/A & N/A
    \\\hline %---------------------------------------
    {\tt SIBLING2} 
    &
    \begin{minipage}{.4\linewidth}
      \footnotesize
      select vertices with the maximal product of 
      the number of predecessors and the number of 
      successors shared with the most recently eliminated vertex
    \end{minipage}
    &
    \begin{minipage}{.2\linewidth}
      \footnotesize
      select edges with the same source / target and the 
      maximal number of successors / predecessors shared with the 
      successors / predecessors of 
      the most recently front / back eliminated edge
    \end{minipage}
    & N/A 
    \\\hline  %---------------------------------------
    {\tt SUCCPRED} 
    &
    \begin{minipage}{.4\linewidth}
      \footnotesize
      select vertices  that were either predecessors or successors of
      the most recently eliminated vertex
    \end{minipage}
    & N/A & N/A 
    \\\hline %---------------------------------------
    {\tt ABSORB} 
    & N/A & N /A &
    \begin{minipage}{.2\linewidth}
      select faces that are absorbed
    \end{minipage}
    \\\hline %---------------------------------------
    {\tt MARKOWITZ} 
    &
    \begin{minipage}{.4\linewidth}
      \footnotesize
      select vertices with  the lowest Markowitz degree
    \end{minipage}
    &
    \begin{minipage}{.2\linewidth}
      \footnotesize
      select edges with the lowest Markowitz degree
    \end{minipage}
    &
    N/A
    \\\hline %---------------------------------------
    {\tt FORWARD} 
    &\multicolumn{3}{c|}{
      select the target next in forward mode
    }
    \\\hline %---------------------------------------
    {\tt REVERSE} 
    &\multicolumn{3}{c|}{
      select the target next in reverse mode
    }
    \\\hline %---------------------------------------
  \end{tabular}
  \caption{Heuristics selection criteria}\label{tab:memOpsHeur}
\end{table}
The driver allows a sequence of heuristics to be selected via string supplied as 
an argument to the commandline switch \lstinline{-H}. The string needs to contain 
the target selection, one of \lstinline{Vertex}, \lstinline{EDGE}, or \lstinline{FACE} followed by 
a sequence of heuristics that should include at least on of the tie breakers \lstinline{FORWARD} or 
\lstinline{REVERSE}. 
Obviously the data locality criteria still are rather simplistic but 
the code is easily extensible for more elaborate strategies. 

The generated code is executable and represents an overall forward mode 
according to \refeqn{eqn:bbfm} with \basicblock\-local preaccumulation in 
cross-country fashion. 

% -----------------------------------------------------------------------------------------
\subsubsection{Using the ANGEL Library}\label{sec:angel}
{\color{red} [ JU: This was a placeholder to talk about the \angel\ lib 
  but I think I will remove this unless somebody strongly objects]}
% -----------------------------------------------------------------------------------------
\subsubsection{CFG Reversal}\label{sec:cfgRevAlg}

\refsec{sec:cfReversal} explains the principal approach to the reversal 
of the CFG. The CFG reversal as implemented in this transformation is 
by itself not useful as unparsed code other than for checking the correctness without 
interference from other transformations. It is a major building block for 
the  
adjoint code generator described in \refsec{sec:BBRev}. 
The \Loop\ counters and \branch\ identifiers are stored the same 
stack data structure that is used for the {\em tape} (introduced in 
\refsec{sec:cfReversal} and also used in \refsec{sec:bbTA}.  
The reversal of loops and branches as detailed in \cite{Utke2006ERo} assumes 
CFGs to be well-structured, that is, essentially to be free of arbitrary jump instructions 
such as \lstinline{GOTO} or \lstinline{CONTINUE}. 
It is of course possible to reverse such graphs, for instance by enumerating
all {\basicblock}s, recording the execution sequence and invoking them according 
to their recorded identifier in  large  \lstinline {SWITCH} statement in reverse order.
Such a reversal is obviously less efficient than a code that, by employing proper 
control flow constructs, aids compiler optimization. 
For the same reason well tuned codes implementing the target function $\bmf$ will 
avoid arbitrary jumps and therefore we have not seen sufficient demand to implement 
a CFG reversal for arbitrary jumps. 

The reversal of  \Loop\ constructs such as \lstinline{do i=1,10} replaces 
the loop variable \lstinline{i} with a generated variable name, say \lstinline{t} and we 
loop up to  the stored execution count which we will call  \lstinline{c} here. 
Then the reversed \Loop\ is \lstinline{do t=1,c}. Quite often the loop body contains 
array dereferences such as \lstinline{a(i)} but \lstinline{i} is no longer available in the 
reversed \Loop. We call this kind of \Loop\ reversal {\em anonymous}. 
To access the proper memory location \lstinline{i} will have to be stored along with the 
\Loop\ counters and \branch\ identifiers in the tape stack.
To avoid this overhead the \Loop\ reversal may be declared {\em explicit}
by prepending \lstinline{!\$openad xxx simple loop} to the \Loop\ in question. 
With this directive the original \Loop\ variable will be preserved,  
the reversed \Loop\ in our example constructed as \lstinline{do i=10,1,-1} and 
no index values for the array references in the \Loop\ body are stored. 
In general the decision when an array index needs to be stored is better answered 
with a code analysis similar to TBR analysis \cite{Hascoet2005bra}. 
Currently we do not have such  analysis available and instead 
as a compromise define the {\em simple}
\Loop\ which can reversed explicitly as follows. 
\begin{itemize}
  \parskip = -2pt
\item \Loop\ variables are not updated within the loop,
\item the \Loop\ condition does not use \lstinline{.ne.},
\item the \Loop\ condition's left-hand side consists only of the \Loop\ variable,
\item the stride in the update expression is fixed,
\item the stride is the right-hand side of the top level \lstinline{+} or \lstinline{-} operator,
\item the loop body contains no index expression with variables that are modified within the loop body.
\end{itemize}
While these conditions can be relaxed in theory, in practice the effort to implement 
the transformation will rise sharply. Therefore they represent a workable compromise 
for the current implementation. 
Because often multidimensional arrays  are accessed with nested loops the 
\Loop\ directive when specified for the outermost loop will assume the validity 
of the above conditions for everything within the \Loop\ body including nested 
\Loop\ and \branch\ constructs. More details on this aspect can be found in 
\cite{Utke2006ERo}. 
% -----------------------------------------------------------------------------------------
\subsubsection{Writing and Consuming the Tape}\label{sec:bbTA}

\refsec{sec:ADIntro} explains the need to store the $\frac{\partial \phi_j}{\partial v_i}$ 
on the tape. 
The writing transformation\footnote{
  see \lstinline{algorithms/BasicBlockPreaccumulationTape/}
}
stores the nonzero elements of local
Jacobians $\bmJ_j$. It is implemented as an extension of the 
preaccumulation in \refsec{sec:BBPreacc} but instead of using the Jacobian elements 
in the forward 
\saxpy\ operations as in \refeqn{eqn:bbfm} we store them 
on a stack as shown for the example code in \reffig{fig:toyPreacc}(a). 
The tape consuming transformation algorithm\footnote{ 
  see \lstinline{algorithms/BasicBlockPreaccumulationTapeAdjoint/}
} 
reinterprets
the \saxpy\ operations generated in \refsec{sec:BBPreacc} 
according to \reftab{tab:saxpyAdj}.
\begin{table}
  \begin{center}
    \begin{tabular}{l|l}
      forward & adjoint\\\hline
      (a): $\dot{y} = \frac{\partial y }{\partial x }\cdot \dot{x}$           & $\overline{x} = \frac{\partial y }{\partial x }\cdot \overline{y} + \overline{x},\;\;\overline{y}=0$ \\
      (b): $\dot{y} = \frac{\partial y }{\partial x }\cdot \dot{x} + \dot{y}$ & $\overline{x} = \frac{\partial y }{\partial x }\cdot \overline{y} + \overline{x}$ \\
      (c): $\dot{y} = \dot{x}$ 					            & $\overline{x} = \overline{y},\;\;\overline{y}=0$\\
      (d): $\dot{y} = 0$ 						            & $\overline{y} = 0$ 
    \end{tabular}
  \end{center}
  \caption{\saxpy\ operations  from \refeqn{eqn:fourSaxpy} and their corresponding adjoints} \label{tab:saxpyAdj}
\end{table} 
The tape writing and consumption implemented in these transformations are 
by themselves not useful as unparsed code other than for checking the correctness without 
interference from other transformations. 
They are, however, major building blocks for the  
adjoint code generator described in \refsec{sec:BBRev}.
% -----------------------------------------------------------------------------------------
\subsubsection{Basic Block Preaccumulation Reverse}\label{sec:BBRev}

This transformation\footnote{
  see \lstinline{algorithms/BasicBlockPreaccumulationReverse}
}
represents the combination of the various transformation 
into a coherent representation that, unparsed into code and post-processed, compiles 
as an adjoint model. 
For the postprocessing steps refer to \refsec{sec:PostProcessor}.
Additional functionality is the generation of code that is able write and 
read checkpoints at a subroutine level, see also \refsec{sec:cgReversal}. 
This part of the transformation relies heavily on the results of side-effect analysis, see 
\refsec{sec:openanalysis} and the inlinable subroutine call mechanism of 
the postprocessor, see \refsec{sec:inline}, to accomplish the checkpointing. 
The driver offers command line options
\begin{itemize}
\item to change subroutine argument intents 
  such that checkpointing can take place; while checkpointing will 
  generally be needed this option is useful 
  for certain application scenarios where the intent change can be avoided.
\item  to validate the \xaif\ input against the schema; the validation takes 
  considerable time for large \xaif\ files
\item to specify a list of subroutines 
  that have a wrappers which should be called in its place
\item to force the renaming of all non-external subroutines which may be necessary 
  for applications which expose only portions of the code to \OpenADF.
\end{itemize}

% -----------------------------------------------------------------------------------------
\section{Language Dependent Components (\OpenADFortTk)}\label{sec:fortfe}

For simplicity we consider all language dependent components part 
of the \OpenAD\ Fortran Tool Kit (\OpenADFortTk). The following 
sections provide details for the various subcomponents that 
are used in transformation tool chain in the following sequence.
\begin{enumerate}	
\item The {\em canonicalizer} converts  
  programming constructs into a canonical form described in \refsec{sec:Canonicalization}. 

\item The compiler front-end \mfefninety\  parses
  Fortran and generates an intermediate representation (IR)
  in the \whirl\ format, see \refsec{sec:open64FeBe}

\item \whirlToxaif\ is a bridge component that
  \begin{itemize}
  \item drives the various program analyses (see \refsec{sec:openanalysis}),
  \item translates the numerical core of the program and  
    the results of the program analyses from \whirl\ to \xaif.
  \end{itemize} see also \refsec{sec:wtxxtw}

\item \xaifTowhirl\ is bridge component that translates the 
  differentiated numerical core represented in \xaif\ 
  into the \whirl\ format. see \refsec{sec:wtxxtw}.

\item \whirlTof\ is the ``unparser'' that converts \whirl\ to
  Fortran, see \refsec{sec:fortfe}

\item The {\em postprocessor} is the  final part of the transformation that
  performs template expansion as well as inlining substitutions, see \refsec{sec:PostProcessor}

\end{enumerate}

% -----------------------------------------------------------------------------------------
\subsection{Canonicalization (incompl.)}\label{sec:Canonicalization}
In \refsec{sec:xaif} we explain how the restriction to the numerical core 
contributes to the  language independence of the transformation
engine.
Still, even for a single programming language, the numerical 
core often exhibits a large variability in expressing semantically 
identical constructs. 
To streamline the transformation engine we reduce this variability by 
{\em canonicalizing} the numerical core. 
This is done using the following Python script.\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADFORTTK_BASE/tools/SourceProcessing/preProcess.py}\\[1ex] %$
Invoking the script with the \lstinline{-h} option displays the following command-line options. \\[1ex]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{preProcessOptions.txt}
\end{boxedminipage}\\[1ex]
Because it is done automatically, the canonicalization does \emph{not} 
restrict the expressiveness of the input programs supplied by the user.
Rather it is a means to reduce the development effort of the transformation engine. 
In the following we describe the canonical form. 

\begin{Can} \label{can:funcToSub}
  All function calls  
  are canonicalized into subroutine calls, see \reffig{fig:funcToSubCall} line 9 on the left 
vs. lines 22,23 on the right.
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=6]{Examples/SRCanonical/func.f90}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=15]{Examples/SRCanonical/func.pre.f90}
\end{minipage}
\caption{Canonicalizing a function call (left, see file 
\lstinline{$OPENADROOT/Examples/SRCanonical/func.f90}), %$
to a subroutine call (right,  see file 
\lstinline{$OPENADROOT/Examples/SRCanonical/func.pre.f90} after running \lstinline{make})} %$
 \label{fig:funcToSubCall}
  \end{figure}
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,lastline=4]{Examples/SRCanonical/func.f90}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=8,lastline=13]{Examples/SRCanonical/func.pre.f90}
\end{minipage}
\caption{Canonicalizing a function definition (left, see file 
\lstinline{$OPENADROOT/Examples/SRCanonical/func.f90}), %$
to a subroutine definition (right,  see file 
\lstinline{$OPENADROOT/Examples/SRCanonical/func.pre.f90} after running \lstinline{make}) %$
for the accompanying call change shown in \reffig{fig:funcToSubCall}} \label{fig:funcToSubDef}
  \end{figure}
  For the transformations, in particular the \basicblock\ level preaccumulation we 
  want to ensure that an assignment effects a single variable on the left-hand side. 
  Therefore  
  the right-hand-side expression ought to be side-effect free.
  While often not enforced by compilers, this is a syntactic requirement for Fortran programs.
  Rather than determining which user-defined functions have side
  effects, we pragmatically hoist \emph{all} user-defined functions.
  Consequently the right-hand-side expression of an assignment consists only of 
  elemental operations $\phi$ typically 
  defined in a programming language as built-in operators and intrinsics.
  The canonicalization of the respective definitions for the function in \reffig{fig:funcToSubCall}
  is  shown in \reffig{fig:funcToSubDef}.
\end{Can}
\begin{Can}\label{can:intrin}
  A particular canonicalization of calls without canonicalization of definitions  
  is applied to certain intrinsics, e.g. the \lstinline{max} and \lstinline{min} intrinsics because in Fortran 
  they do not have closed form expressions for the partials. \OpenADF\ provides a run time 
  library containing definitions for the respective subroutines called instead.
  An example is shown in \reffig{fig:maxToSub}.  
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran]{Examples/MaxCanonical/func.f90}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=17]{Examples/MaxCanonical/func.pre.f90}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,lastline=16]{Examples/MaxCanonical/func.pre.f90}
\end{minipage}
\caption{Canonicalizing a call to {\tt max} (top left,  see file 
\lstinline{$OPENADROOT/Examples/MaxCanonical/func.f90}), %$
to two subroutine calls (bottom left) and the accompanying definition (right,  see file 
\lstinline{$OPENADROOT/Examples/MaxCanonical/func.pre.f90} after running \lstinline{make})} %$
 \label{fig:maxToSub}
  \end{figure}
\end{Can}
\begin{Can}\label{can:param}
  Non-variable actual parameters are hoisted to temporaries.
  Any value passed to a routine could conceivably need augmentation. Furthermore, only variables
  can be augmented. 
  Consequently, {\OpenAD} hoists all non-variable actual parameters into temporaries.
  An example is shown in \reffig{fig:ArgExprToTemp}.
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=6]{Examples/ArgExprCanonical/func.f90}
\end{minipage}
\hspace{.02\linewidth}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=9]{Examples/ArgExprCanonical/func.pre.f90}
\end{minipage}
\caption{Canonicalizing a subroutine argument (left, see file 
\lstinline{$OPENADROOT/Examples/ArgExprCanonical/func.f90}), %$
into a temporary variable (right,  see file 
\lstinline{$OPENADROOT/Examples/ArgExprCanonical/func.pre.f90} after running \lstinline{make}) %$
} \label{fig:ArgExprToTemp}
  \end{figure}
\end{Can}
Because none of the above canonicalizations are intended to produce manually 
maintainable code we prefer simplicity over more sophisticated transformations 
e.g. a module generator which abstracts dimension information shared between common blocks. 

% -----------------------------------------------------------------------------------------
\subsection{Compiler Front-End Components (from \OpenSixtyFour)} \label{sec:open64FeBe}

The choice of \OpenSixtyFour\ for some of the programming-language-dependent 
components ensures some initial robustness of the tool that is afforded by an 
industrial-strength compiler. 
The Center for High Performance Software Research (HiPerSoft) at Rice University 
develops \OpenSixtyFour\ \cite{open64Web} as a 
multi-platform version of the SGI Pro64/Open64 compiler
suite, originally based on SGI's commercial MIPSPro compiler.

\OpenADF\ uses the parser, an internal representation and the unparser 
of the \OpenSixtyFour\ project.
The classical compiler parser \mfefninety\ produces a representation of the Fortran 
input in a format known as very high level or source level \whirl\ . 
The \whirl\ representation can unparsed into Fortran using the 
tool \whirlTof.
The source level \whirl\
representation resembles a typical abstract syntax tree with the 
addition of machine type deductions. 
The original design of \whirl\ in particular the descent to 
lower levels closer to machine code  enables good optimization 
for high performance
computing in Fortran, C, and C++. HiPerSoft's main
contribution to the \OpenSixtyFour\ community has been the source 
level extension to \whirl\
which is geared towards supporting source-to-source transformations and 
it 
has invested significant effort in the \whirlTof\ unparser.

For the purpose of AD, user-supplied hints and required 
input is typically not directly
representable in programming languages such as Fortran and 
therefore represented by pragmas.  
For example,
an AD tool must know which variables in the code for $\bmf$ are
independent and which are dependent, see also \refsec{sec:pragmas}.
For \OpenADF\ we extended the
\OpenSixtyFour\ components to generate and unparse these pragma nodes represented in \whirl.
The behavior is 
similar to many other special-purpose Fortran pragma systems such as
OpenMP \cite{openmpWeb}. 
\subsubsection{Parser}
The parser binary can be found in the following file. \\[1ex] 
\hspace*{.3cm}\lstinline{$OPEN64ROOT/crayf90/sgi/mfef90}\\[1ex] %$
The full set of options can be retrieved with the command line flag \lstinline{-h}. 
The options of interest for the \OpenADF\ context are the following.\\[1ex]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{mfef90Options.txt}
\end{boxedminipage} \\[1ex]
As indicated above, the flag \lstinline{-z} {\bf has to be specified}. The majority of the other 
options are not useful in the \OpenAD\ context.  There are however some debugging and tracing options that can be specified with the \lstinline{-u} flag.  

\subsubsection{Unparser}
The unparser binary can be found in the following file.\\[1ex] 
\hspace*{.3cm}\lstinline{$OPEN64ROOT/whirl2f/whirl2f}\\[1ex] %$
and  the full set of options can be retrieved  by invoking it without any arguments. 
The options of interest in shown in \reffig{fig:whirl2fOptions}.
\begin{figure}[t]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{whirl2fOptions.txt}
\end{boxedminipage}
\caption{Subset of \whirlTof\ options that are relevant for \OpenADF.}\label{fig:whirl2fOptions}
\end{figure}
As indicated, the flag \lstinline{-openad} {\bf has to be specified}. 
The name for the 
abstract active type that can be supplied with the \lstinline{-openadType} flag  
{\bf must be identical} to the name passed to the post processor with the \lstinline{-a} flag,
see \refsec{sec:PostProcessor}. 
% -----------------------------------------------------------------------------------------
\subsection{Translating between \whirl\ and \xaif}\label{sec:wtxxtw}

Two features of \xaif\ shape the
contours of \whirlToxaif\ (translate \whirl\ to \xaif) 
and \xaifTowhirl\ (translate \xaif\ to \whirl).  
Both are located in the following directory.\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADFORTTKROOT/bin/}\\[1ex] %$
Invoking the respective component with the \lstinline{-h} option displays command-line options. 
The options of the \whirlToxaif\ and \xaifTowhirl\ component are shown in 
\reffig{fig:whirl2xaifOptions} and \reffig{fig:xaif2whirlOptions}, respectively.
\begin{figure}[h]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{whirl2xaifOptions.txt}
\end{boxedminipage}
\caption{Options of \whirlToxaif.}\label{fig:whirl2xaifOptions}
\end{figure}
\begin{figure}[h]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{xaif2whirlOptions.txt}
\end{boxedminipage}
\caption{Options of \xaifTowhirl.}\label{fig:xaif2whirlOptions}
\end{figure}

Because \xaif\
represents only the numerical core of a program, a number of \whirl\
statements and expressions are not translated into \xaif\.  For
instance, \xaif\ does not represent dereferences for user-defined types 
because numerical operations simply will not involve the user defined 
type as such but instead always the numerical field that eventually is a member 
of the user defined type (hierarchy). 
Derived type references are therefore {\em scalarized}. This consists of converting
the derived type reference into a canonically named scalar variable.
To ensure correctness, this scalarization must be undone upon backtranslating 
to \whirl. The effect can be observed in the generated \xaif\ for \lstinline{v\%f} where 
the dereference 
shows up for example 
as \lstinline{<xaif:SymbolReference vertex_id="1" scope_id="4" symbol_id="scalarizedref0"\/>}
and in the \xaif\ symbol table we would find \lstinline{scalarizedref0} as a scalar variable with 
a type that matches that of \lstinline{f}. 
However, variable references of user defined type can still show up in the \xaif\ for 
instance as subroutine parameters. Such references are listed with an 
{\em opaque} type. Statements in the original code that do not have an 
explicit representation in the  \xaif, 
such as I/O statements, take the form of annotated markers that retain 
their position in the representation during the transformation of the \xaif.  
Given the original
\whirl\ and the differentiated \xaif\ (with the scalarized objects, opaque types
and annotated markers intact), \xaifTowhirl\ is able generates new \whirl\ representing the
differentiated code while restoring the statements and types not shown in the \xaif.   

Furthermore, \xaif\ provides a way to represent the results of  common
compiler analyses.  To provide these to the transformation engine 
\whirlToxaif\ acts as a driver for the analyses provided by the 
\OpenAnalysis\ package, see \refsec{sec:openanalysis}.
In particular it implements the abstract \OpenAnalysis\ interface
to the \whirl\ IR. The results returned by \OpenAnalysis\ are then 
translated into a form consistent with \xaif.

The companion tool \xaifTowhirl\ backtranslates \xaif\ into \whirl. 
As indicated above it has to take care of restoring filtered out 
statements and type information. Because the differentiated \xaif\ 
relies on postprocessing, see \refsec{sec:PostProcessor}, 
its other major challenge is the 
creation of \whirl\ that contains the postprocessor directives related to
three tasks to be accomplished by the postprocessor. 
\begin{itemize} 
\item The declaration and use of the active variables;
\item The placement of inlinable subroutine calls;
\item The demarcation of the various alternative subroutine bodies used in the subroutine template replacements.
\end{itemize}  

% -----------------------------------------------------------------------------------------
\subsection{Postprocessing (incompl.)}\label{sec:PostProcessor}
The postprocessor performs the three tasks outlined at the end of \refsec{sec:wtxxtw}.
This is done using the following Python script.\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADFORTTK_BASE/tools/SourceProcessing/postProcess.py}\\[1ex] %$
Invoking the script with the \lstinline{-h} option displays the command-line options
shown in \reffig{fig:postProcessOptions}.
\begin{figure}[h]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{postProcessOptions.txt}
\end{boxedminipage}
\caption{Options of the post processor}\label{fig:postProcessOptions}
\end{figure}


\subsubsection{Use of the Active Type}\label{sec:activeType}
The simplest postprocessing task is the concretization of the active variable declarations 
and uses. The main rationale for postponing the concretization of the active type is flexibility 
with respect to the actual active type implementation.
This is done via the \lstinline{-t} flag. 
Using the text replacement in the  postprocessor 
it is much easier to adapt to a changing active type implementation than to 
find find the proper \whirl\ representation and modify \xaifTowhirl\ to create it.
However, it should be noted, that the ease of adaptation is clearly correlated to the 
simplicity and in particular the locality of the transformation. The advantage disappears with 
increased complexity of the transformation.   
For an active variable, for example  \lstinline{v},  the representation created 
by \xaifTowhirl\ in \whirl\ and then unparsed to Fortran,
shows up by default as \lstinline{TYPE (oadactive) v}.\footnote{See also the \lstinline{-t} flag 
in \refsec{sec:wtxxtw} to change the name of the abstract active type.} 
In \whirl\ the type remains abstract because the accesses to the conceptual value and derivative components 
are represented as function calls \lstinline{__value__(v)} and \lstinline{__deriv__(v)} respectively.
The concretized versions created by the postprocessor for the current active type implementation, 
see \lstinline{runTimeSupport/scalar/OAD_active.f90} are by default 
\lstinline{type(active) v} for the declaration and simply \lstinline{v\%v} for the value \lstinline{v\%d} for 
the derivative component respectively and each subroutine will also receive an additional 
\lstinline{USE} statement which makes the type definition in \lstinline{OAD_active} known.
The abstract active type  name can be changed with the \lstinline{--abstractType} option and 
the concrete active type name  can be changed with the \lstinline{--concreteType} option, respectively.

\subsubsection{Inlinable Subroutine Calls}\label{sec:inline}
The second task, the expansion of inlinable subroutine calls, is more complex because 
any call expansion has now the scope of a subroutine body. The calls unparsed from \whirl\ to 
Fortran are regular subroutine call statements. They are however preceded by an inline  pragma
\lstinline{!\$openad inline <name(parameters)>}  
that directs the postprocessor to expand the following call according to a definition 
found in an input file\footnote{
specified with command line option \lstinline{-i} which defaults to \lstinline{ad_inline.f}
}, see also \lstinline{runTimeSupport/simple/ad_inline.f}.
Pushing a preaccumulated sub-Jacobian value as in  \reffig{fig:toyPreaccRev}(a) might appear 
in the code for example from \refsec{sec:reverseMode} as\footnote{
see file \lstinline{$OPENADROOT/Examples/OneMinuteReverse/head.prepped.pre.xb.x2w.w2f.f} after running \lstinline{make}) %$
} \\[1ex]
\hspace*{.05\textwidth}\begin{minipage}{.6\textwidth}
\small
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=44,lastline=45]{Examples/OneMinuteReverse/head.prepped.pre.xb.x2w.w2f.f}
\end{minipage}\\
for which we have a definition in \lstinline{ad_inline.f} as \\[1ex]
\hspace*{.05\textwidth}\begin{minipage}{.6\textwidth}
\small
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=48,lastline=56]{Examples/OneMinuteReverse/ad_inline.f}
\end{minipage}\\
The postprocessor ignores the \lstinline{DECLS} section and  expands this to\footnote{
see file \lstinline{$OPENADROOT/Examples/OneMinuteReverse/head.prepped.pre.xb.x2w.w2f.post.f90} after running \lstinline{make}) %$
}\\[1ex]
\hspace*{.05\textwidth}\begin{minipage}{.6\textwidth}
\small
\lstinputlisting[basicstyle=,frame=single,language=Fortran,firstline=102,lastline=103]{Examples/OneMinuteReverse/head.prepped.pre.xb.x2w.w2f.post.f90}
\end{minipage}\\
Note, that for flexibility 
any calls with inline directives for which the postprocessor cannot find an inline definition remain 
unchanged. For example we may instead compile the above definition for \lstinline{Push} and link 
it instead.

\subsubsection{Subroutine Templates}\label{sec:templates}
The third task, the subroutine template expansion is somewhat related the inlining. 
In our example above, the tape storage referred to in the \lstinline{Push} need to be 
defined and in the design the subroutine template is the intended place for these definitions, 
in our example achieved through including the \lstinline{use} statement in the template code, 
see \reffig{fig:jointACTemplate}.
The main purpose of the subroutine template expansion however is to orchestrate the 
call graph reversal. The reversal schemes introduced in \refsec{sec:cgReversal}
can be realized by carrying state through the call tree. 

The basic building blocks from the transformations in \refsec{sec:xaifBooster}
are variants \lstinline{S}$_i$ of the body of an original subroutine body \lstinline{S}$_0$, 
each accomplishing one of the tasks shown as one of the squares with arrows in \reftab{tab:leg}. 
For instance, the taping variant is created by the transformation in \refsec{sec:bbTA} or
the checkpointing by the transformation in \refsec{sec:BBRev}. 
To integrate the $S_i$ 
into a particular reversal scheme, we need to be able to make all subroutine calls 
in the same fashion as in the original code and, at the same time, 
control which task each subroutine call accomplishes.  
We replace the original subroutine body with a branch structure in which each branch contains 
one $S_i$. 
The execution of each branch is determined by a global control structure whose members 
represent the state of execution in the reversal scheme.
The branches contain code for pre- and post-state transitions enclosing the respective $S_i$.
This ensures that the transformations producing the $S_i$
do not depend on any particular reversal scheme.
\begin{figure}
\hspace*{8ex}\begin{tabular}{l@{\hspace{.3cm}}c@{\hspace{1cm}}l@{\hspace{.3cm}}c}
(a)&
\begin{minipage}[t]{3cm}
\vspace*{-.3cm}
\includegraphics[width=3cm]{code_template}
\end{minipage}&
(b)& 
\begin{minipage}[t]{4cm}
\fontsize{8pt}{9pt}
\verbatiminput{code/splitTemplate.pf}
\end{minipage}
\\
\end{tabular}
\caption{Subroutine template components (a), split-mode Fortran90 template (b) } \label{fig:codeTemplate}
\end{figure}
The postprocessor
inserts the \lstinline{S}$_i$ into a subroutine template, schematically 
shown in \reffig{fig:codeTemplate}(a).
The template is written in Fortran. Each subroutine in the 
postprocessor Fortran input is transformed according to either 
a default subroutine template found in a \lstinline{ad_template.f} file or 
in a file specified in a \lstinline{!\$openad XXX Template <file name>}
pragma to be located in the subroutine body. 
The input Fortran also contains \lstinline{!\$openad begin replacement <}$i$\lstinline{>} paired 
with pragmas \lstinline{!\$openad end replacement}. Each such pair delimits a code variant \lstinline{S}$_i$ 
and the postprocessor matched the respective identifier $i$ (an integer) with the 
identifier given in the template \lstinline{PLACEHOLDER_PRAGMA}.  

Split reversal is the simplest static call graph reversal. We first execute the entire computation 
with the augmented forward code $(S_2)$ and then 
follow with the adjoint $(S_3)$. 
From the task pattern 
shown in \reffig{fig:split} it is 
apparent that, aside from the top-level routine, there is 
no change to the state structure within the call tree.
Therefore, there is no need for state changes within the template. 
Since no checkpointing is needed either, we have only two tasks: 
producing the tape and the adjoint run.
\reffig{fig:codeTemplate}(b) shows a simple split-mode template, see also \lstinline{runTimeSupport/simple/ad_template.split.f}.
The state is contained in \lstinline{rev_mode}, a static Fortran90 variable, see \lstinline{runTimeSupport/simple/OpenAD_rev.f90}
of type \lstinline{modeType} also defined in this module.  
In order to perform a split-mode reversal for the entire computation, a driver routine 
calls the top-level subroutine first in taping mode and then in adjoint mode.

\reffig{fig:joint} illustrates the task pattern for a joint reversal scheme that requires state changes 
in the template and requires more code alternatives. \reffig{fig:jointACTemplate} shows a 
simplified joint mode template, see also \lstinline{runTimeSupport/simple/ad_template.joint.f}. 
The state transitions in the template directly relate to the pattern 
shown in \reffig{fig:joint}. Each prestate change applies to the callees of the current 
subroutine. Since the argument store $(S_4)$ and restore $(S_6)$ do not contain any subroutine calls they 
do not need state changes. 
Looking at \reffig{fig:joint}, 
one realizes that the callees of 
any subroutine executed in plain forward mode $(S_1)$ 
never store the arguments (only callees of subroutines in 
taping mode do). 
This explains lines 18, 25, and 30. 
Furthermore, all callees of a routine currently in 
taping mode are not to be taped but instead run in plain forward mode, as reflected in lines 27 and 28. 
Joint mode in particular means that a subroutine called in taping mode $(S_2)$ has its adjoint $(S_3)$ executed immediately 
after $S_2$. 
This is facilitated by line 33, which makes the condition in line 35 true, and we execute 
$S_3$  without leaving the subroutine.  
Any subroutine executed in adjoint mode has its direct 
callees called in taping mode, which in turn triggers their respective adjoint run. This is done in 
lines 37--39.   
Finally, we have to account for sequence of callees in a subroutine; that is, when we are done with this subroutine, 
the next subroutine (in reverse order) needs to be adjoined. This process is triggered by calling the subroutine in taping mode, as done 
in lines 41--43. 
The respective top-level routine is called by the driver with the state structure having both \lstinline{tape} and 
\lstinline{adjoint} set to \lstinline{true}. 
\begin{figure}
\begin{center}
\vspace*{-1cm}
\begin{minipage}{.8\linewidth}
\fontsize{8pt}{9pt}
\verbatiminput{code/jointTemplate.pf}
\end{minipage}
\end{center}
\caption{Joint mode Fortran90 template with argument checkpointing} \label{fig:jointACTemplate}
\end{figure}

% -----------------------------------------------------------------------------------------
\section{Ancillary Tools}\label{sec:ancillaryTools}
We provide a number of helper scripts to manage the \OpenADF\ installation.
% -----------------------------------------------------------------------------------------
\subsection{The \lstinline{openadUpdate} and \lstinline{openadStatus} Scripts} \label{sec:openadUpdate}
This section is useful only for \OpenADF\ installation made from source 
code repositories. The binary distribution does not include the scripts 
and source tar ball does not include the repository data.
To get \OpenADF\ components and update the 
revision from the source code repositories  it is easiest to use the \lstinline{openadUpdate} script 
which is written in Python \cite{pythonweb} and can be found  at \\[1ex]
\hspace*{.3cm}\lstinline{$OPENDADROOT/bin/openadUpdate}\\[1ex] %$
It provides the following command line flags.\\[1ex]
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{openadUpdateFlags.txt}
\end{boxedminipage}\\[1ex]
Typically it will be invoked without any flags. To obtain the examples for this manual 
one will, however,  need the Mercurial tool \cite{mercurialWeb} and use the \lstinline{-t} flag; 
see also \refsec{sec:compilingManual}.
The \lstinline{openadUpdate} script uses the 
default locations for the component repositories given in 
\lstinline{$OPENADROOT/openad_config.py}. %$
A log named \lstinline{openadUpdate.}{\em timestamp}\lstinline{.log~} will contain  output and 
potential error messages.

The \lstinline{openadStatus} script is primarily for development purposes to obtain an overview 
of the status of the various repositories. It can also be used to see if an update from 
the source repositories is ready. That would be indicated by an \lstinline{I} in the 
\lstinline{Remote} column of \lstinline{openadStatus} output such as the following. \\[1ex]
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{openadStatusOutput.txt}
\end{boxedminipage}\\[1ex]
The script  provides the following command line flags.\\[1ex]
\begin{boxedminipage}{\linewidth}
\scriptsize\verbatiminput{openadStatusFlags.txt}
\end{boxedminipage}\\[1ex]
Unlike \lstinline{openadUpdate}, the \lstinline{openadStatus} script determines the repository type and URL 
not based on the defaults in  \lstinline{$OPENADROOT/openad_config.py} %$
but instead uses the actual data found in the respective directories.

% #########################################################################################
\chapter{Application}\label{sec:application}
This applications section intends to augment the explanations given so far. 
We use two small examples to further illustrate the  explanations given in \refsec{sec:oneMinute} and 
discuss a more complicated example in \refsec{sec:shallow}. 
% -----------------------------------------------------------------------------------------
\section{Two Small Examples}\label{sec:toyExample}
Both examples follow the same prinicipal steps as the example in \refsec{sec:oneMinute} :
\begin{itemize}
\item setup of a \lstinline{Makefile} that uses the \lstinline{openad} script
\item identification of independent and dependent variables
\item driver code to setup the derivative computation and obtain the derivative values
\end{itemize}
We do not explain these fundamental steps again but instead concentrate on various aspects 
specific to the examples. 
\begin{itemize}
\item select the source code to be transformed
\item computing a whole Jacobian either iteratively or in vector mode
\item controlling call graph reversal mode
\end{itemize}
To obtain the source code for the examples in this section please refer to \refsec{sec:compilingManual}. 
To run the examples one needs to install \OpenADF\ following the instructions in \refsec{sec:dab}.
As in 
\refsec{sec:oneMinute}
one can change the default Fortran  and C compilers for these examples by setting the
environemt variables \lstinline{F90C} and \lstinline{CC} respectively. 
We have tested the examples with \lstinline{gfortran}, NAG \lstinline{f95} and Intel's \lstinline{ifort}.  

\subsection{FDC example}\label{sec:fdcExample}
This example code was taken from the Minpack test problem ``flow in a driven cavity''. 
The source code for the problem can be found under \lstinline{$OPENADROOT/Examples/OneMinute/}%$
in file \lstinline{head.f} and a simple driver in \lstinline{driver.f90} and an executable named \lstinline{driver} can be 
produced by running\\[1ex] 
\hspace*{.3cm}\lstinline{cd $OPENADROOT/Examples/FDC}\\ %$
\hspace*{.3cm}\lstinline{make}\\[1ex]
To illustrate the use of \OpenADF\ and provide a comparison with 
finite differences we have setups with driver source files and \lstinline{Makefile}s in the following subdirectories
\begin{description}
\item[\tt FD] - for a finite difference approximation to the Jacobian
\item[\tt TLM] - for the  \OpenADF\ tangent linear model, i.e. forward mode
\item[\tt ADMsplit] - for the \OpenADF\ adjoint model in split mode (see also, \refsec{sec:cgReversal})
\item[\tt ADMjoint] - for the \OpenADF\ adjoint model in joint mode (see also, \refsec{sec:cgReversal})
\end{description}
The respective executables can be obtained by running \\[1ex]
\hspace*{.3cm}\lstinline{cd} {\em subDir}\\ 
\hspace*{.3cm}\lstinline{make} \\[1ex]
in each 
subdirectory which then produces an executable named\\[1ex]
\hspace*{.3cm}\lstinline{driver}{\em subDir}\\[1ex]
One can compare the produced output and observe matching values for the Jacobian entries. 
We suggest to also compare the driver source files and the \lstinline{Makefile}s
to see the differences between the variants. 

\noindent
{\bf What to transform:} Note that part of the computation is an initialization done in \lstinline{init.f}. All driver files call 
the \lstinline{init} routine but it is \underline{\em not part of the transformation} because we only want to differentiation 
with the respect to the initial value in variable \lstinline{x} and  not with respect to the parameters that are 
used in \lstinline{init}. Because the \lstinline{init} routine is not transformed its floating point argument will retain 
the original type while the argument type of \lstinline{x} in \lstinline{head} has changed to the active type. 
Consequently we use a variable \lstinline{x0} to compute the initial value then copy it from there into the active variable \lstinline{x}.    

\noindent
{\bf How to obtain the whole Jacobian:} In these examples we use a single scalar derivative associated with each scalar program variable. 
Consequently in one sweep we can obtain in forward mode one product $\bmJ\dot{\bmx}$ or in reverse mode one product $\bar{\bmy}^T\bmJ$. 
This means we need either $n$ forward sweeps or $m$ reverse sweeps for the whole Jacobian\footnote{Because one can see that the Jacobian 
is in fact sparse one could employ various compression techniques to reduce the effort but we do not do this here to keep the example simple.}.   
This is reflected in the respective loops in the driver routines that wrap the calls to the differentiated \lstinline{head} routine where in each loop
itertation we 
initialize $\dot{\bmx}$ or $\bar{\bmy}$ to a column of the $n\times n$ or $m\times m$ identity matrix and compute the respective 
column or row of $\bmJ$.

\noindent
{\bf Controling split and joint mode in the adjoint model:} The principal behavior (split or joint mode) of the call graph reversal is encoded 
in the template file that the \lstinline{openad} script uses which is controled by the \lstinline{--mode} flag which for reverse mode is set 
either to \lstinline{rs} or \lstinline{rj}. Aside from that difference which is evident in the respective \lstinline{Makefile}s, one can 
see in the driver logic that the split reaches up to the top level routine \lstinline{head} which in the driver is first invoked 
for the taping sweep (the code variant is selected by calling \lstinline{OAD_rev_tape()}) 
and then again for the adjoint sweep  (the code variant is selected by calling  \lstinline{OAD_rev_adjoint()}). 
In joint mode on the other hand the implicit behavior encoded in the template is that the adjoint sweep follows immediately after 
the taping sweep and consequently we see only one call to \lstinline{head} initially for the taping variant  
and the template internally then selects and invokes the adjoint sweep variant of the code.    


\subsection{Box model example}\label{sec:boxModelExample}
This example code was taken from a simple oceanographic box model test. 
The source code for the problem can be found under \lstinline{$OPENADROOT/Examples/BoxModel/}%$
in file \lstinline{head.f} and a simple driver in \lstinline{driver.f90} and an executable named \lstinline{driver} can be 
produced by running\\[1ex] 
\hspace*{.3cm}\lstinline{cd $OPENADROOT/Examples/BoxModel}\\ %$
\hspace*{.3cm}\lstinline{make}\\[1ex]
and followin the same approach as in \refsec{sec:fdcExample} we have 
variants in the following 5 subdirectories:
\begin{description}
\item[\tt FD] - for a finite difference approximation to the Jacobian
\item[\tt TLM] - for the  \OpenADF\ tangent linear model, i.e. forward mode
\item[\tt TLMvec] - for the  \OpenADF\ forward vector mode 
\item[\tt ADMsplit] - for the \OpenADF\ adjoint model in split mode (see also, \refsec{sec:cgReversal})
\item[\tt ADMjoint] - for the \OpenADF\ adjoint model in joint mode (see also, \refsec{sec:cgReversal})
\end{description}
Here we have an 
additional variant for {\em vector mode}, see below under ``How to obtain the whole Jacobian''. 
The noteworthy differences to the example in \refsec{sec:fdcExample} are explained below.
 
\noindent
{\bf What to transform:} This example stores the computed data as module variables (see \lstinline{all_globals_mod.f}.
The module variables are accessed by the top level routine that computes the model (see \lstinline{box_forward} in 
\lstinline{head.f})  but also by initializations  (for example \lstinline{box_ini_fields)}.
Because of the common access to the global data we put all the code in \lstinline{all_globals_mod.f} and 
\lstinline{head.f} together into one file called \lstinline{numCore.f} (see the respective \lstinline{Makefile}s 
in the \OpenADF\ variants of the example)  and transform the entire code. 
After running \lstinline{make} one can inspect the transformed code in \lstinline{numCore.pre.xb.x2w.w2f.post.f}
and find that the module variables \lstinline{T} and \lstinline{S} have had their type changed to 
\lstinline{type(active)} and the 
transformed \lstinline{box_ini_fields} correctly references them with the value component of the active type. 

\noindent
{\bf Compile order:} Note, that the transformed source code in \lstinline{numCore.pre.xb.x2w.w2f.post.f} 
contains the modified module which is referenced by the driver routine so that we can access the derivative
components. Therefore the compilation of \lstinline{numCore.pre.xb.x2w.w2f.post.f} has to happen before 
the compilation of the driver which is reflected in the \lstinline{Makefile}.

\noindent
{\bf How to obtain the whole Jacobian:} This example has variant in subdirectory \lstinline{TLMvec} which 
computes all needed directions in one sweep by propagating an array of derivative components.  
The \lstinline{openad} script links a different active type definition (see also \refsec{sec:activeTypeDefs})
when the \lstinline{--mode} flag is set to \lstinline{fv}, see the \lstinline{Makefile}.
In the example module the length of the derivative component array is hard coded but obviously one should  
change that definition to adapt it to the application context. 

% -----------------------------------------------------------------------------------------
\section{Shallow Water Model (to be reworked)}\label{sec:shallow}
In this section we will use a practical application to highlight 
advanced aspects arising for more complicated applications. 
The model is a time stepping scheme which eventually computes 
a scalar valued cost function. We generate an adjoint model 
to compute the gradient.  

% -----------------------------------------------------------------------------------------
\subsection{Collect and Prepare Source Files} 
The entire model consists of many subroutines distributed over various 
source files and the existing build sequence involves C preprocessing.
To perform the static code analysis as explained in \refsec{sec:openanalysis}
all code that takes part in computation of the model has to be visible 
to the tool which means it has to be concatenated into a single file. 
It is possible to do this for all source files of the model but in many 
cases this will include code for ancillary tasks such as diagnostics 
and data processing not directly related to the model computation.
Often it is better to filter out such ancillary code. 
\begin{itemize}
\item The static code analysis and subsequently the code transformation
has to make conservative assumptions to ensure 
correctness, e.g. for alias analysis this means an overestimate of 
the memory locations that can alias each other. One of the effects of these potential aliases
are additional assignments in the generated code  which lead to 
a less efficient adjoint. Including ancillary sources may cause more conservative 
assumptions to be made and therefore lead to an unnecessary loss in efficiency.
\item While the numerical portions frequently have been tuned and made platform 
neutral the ancillary portions often are platform dependent and may contain
Fortran constructs that the language dependent components handle improperly or 
not at all. While all tools in principle strive for complete language coverage 
the limited development resources can often not be spared to cover 
infrequently used language aspects and rather need to be focused on features 
that actually benefit capabilities and efficiency for a wide range of applications.
\end{itemize}
As for all AD tools in existence today the above concerns also apply to 
\OpenADF\ and  users are kindly asked to keep them in mind when
preparing the source code.

\refsec{sec:toyExample} indicates the need for a modification 
to the code that drives the model computation to at least 
preform the seeding and extraction of the derivatives. 
The easiest approach to organize the driver is to identify (or create) 
a top level subroutine that computes the model with a single call. 
This routine and all code it requires to compute the model 
become the contents of the single file to be processed by the tool chain.
The independent and dependent variables should be identified in the top level routine.  

% -----------------------------------------------------------------------------------------
\subsection{Orchestrate a Reversal and Checkpointing Scheme}
Joint and split reversal, see \refsec{sec:cgReversal} are two special cases 
of a large variety of reversal schemes. The model here involved a time stepping 
scheme controlled by a main loop. \OpenADF\ supports automatic detection of the 
data set to be checkpointed at a subroutine level. To use this feature the loop 
body is encapsulated into a inner loop subroutine \lstinline{I}. To realize a nested checkpointing scheme
we select a number \lstinline{i} for the inner checkpoints, 
divide the original loop bound \lstinline{t} by \lstinline{i} and encapsulate the inner loop 
into an outer loop subroutine \lstinline{O} schematically shown in \reffig{fig:checkpointLoops} 
which is invoked \lstinline{o} times\footnote{
for simplicity disregarding remainders \lstinline{o=t/i}.
}
\begin{figure}
\begin{tabular}{cc}
\begin{minipage}{5cm}
\includegraphics[height=4.3cm]{checkpointLoops}
\end{minipage}
&
\begin{minipage}{6cm}
\includegraphics[height=4cm]{checkpointLoopsNew2}
\end{minipage}\\
(a)& (b)
\end{tabular}
\caption{Modification of the original code (a) to allow 2 checkpointing levels (b)}\label{fig:checkpointLoops}
\end{figure}
Now we can describe the reversal scheme with the call tree shown in \reffig{fig:checkpointct}.
\begin{figure}
\begin{center}
\includegraphics[height=4.3cm]{swMode}
\end{center}
\caption{Checkpointing scheme, the \lstinline{.*} indicating \lstinline{.+(o-1)i}} \label{fig:checkpointct}
\end{figure}
The state changes can be encapsulated in four templates, one joint mode template for \lstinline{top}
and all its callees except \lstinline{O}, one for all callees of \lstinline{I} and one  each for 
\lstinline{O} and \lstinline{I}.  
The collection of downloadable test problems contains the 
model and the four subroutine templates.
\reffig{fig:checkpointLoops}(b) shows the \lstinline{cost} subroutine called from 
\lstinline{I} as well as from \lstinline{top}. 
However, according to \reffig{fig:checkpointLoops} we would need two versions of 
\lstinline{cost}, one that as callee of \lstinline{top} is reversed in joint mode and 
one as callee of \lstinline{I} is reversed in split mode. In order to maintain 
the static reversal approach\footnote{
A dynamic reversal scheme is forthcoming.
}
one needs to duplicate \lstinline{cost}.

% -----------------------------------------------------------------------------------------
\subsection{File I/O and Simple Loops}
The model code uses both the NetCDF library as well as 
the built in Fortran I/O during the initialization and 
output of results. Because  in the model computation 
no intermediate values are written and read during 
the model computation there is no loss of dependency information. 
However, the I/O can lead to problems, for instance 
when an activated array is initialized. The prevalent 
lack of type checking in Fortran may lead to setting 
the first half of the \lstinline{\%v} and \lstinline{\%d} values 
instead of setting all of the \lstinline{\%v} values. 
This is a well known consequence of the active type 
implementation. While one could argue that the code should 
be generated to avoid reading or writing the derivative information
this is not always the actually desired behavior, in particular 
not if one reads or writes active intermediate variables. 
A simple and effective measure to circumvent this problem 
is let the initialization remain an external routine 
in which case \OpenADF\ will insert conversion routines 
for external subroutine parameters that are active at the 
call site. 
It should be noted that this approach does not work 
when instead of passing a parameter the external routine refers 
to active global variables.
  
Early tests showed a considerable amount of runtime and memory 
spent on taping array indices used in loops. 
The {\em simple} loop concept introduced in \refsec{sec:cfgRevAlg}
is designed to eliminate much of this overhead. 
Not all loops within the given model code satisfy the conditions 
so as an additional step throughout the model code 
we identified the conformant loop constructs to 
the tool using the simple loop pragma. The resulting efficiency gain
was about a factor 4 in run time and more than a factor 10 in memory 
use.

% -----------------------------------------------------------------------------------------
\subsection{Results}
\reffig{fig:sensMap} shows as an example output a map of sensitivities of 
zonal volume transport through the Drake Passage 
to changes in bottom topography everywhere in a barotropic ocean model 
computed from the shallow water code by P. Heimbach.
\begin{figure}
\begin{center}
\includegraphics[height=6cm]{sensMap}
\end{center}
\caption{Sensitivity (gradient) map for $2\times 2$ degree resolution}\label{fig:sensMap}
\end{figure} 
The adjoint model generated with the current version of \OpenADF\ applied to the 
shallow water code achieves 
a run time that is only about 8 times that of  plain model computation.
We expect the ongoing development of \OpenADF, see also \refsec{sec:mods} to yield 
further efficiency gains.

% -----------------------------------------------------------------------------------------
\section{Wrapping Higher-Level Calls using Stubs and Templates}\label{sec:higherLevel}
Portions of the code that implement well defined higher-level mathematical mappings,  
such as linear solves, it is generally preferable to formulate the mapping for the derivatives 
directly rather than differentiating the code that implements the mapping. 
This section we provides a few examples how to orchestrate the wrapping.

% .........................................................................................
\subsection{Self Adjoint Solves}\label{sec:selfAdjoint}
In \lstinline{$OPENADROOT/Examples/SelfAdjoint/} %$
one can find a simple example for 
a selfadjoint solve of the following system
\[
\left[\begin{array}{cc}
2 & 3 \\
3 & 2 
\end{array}\right] \bmx=\bmb \quad .
\]
The function in question is $\bmf: \bmb \mapsto \bmx$. 
Because the matrix is symmetric and fixed we can write the adjoint simply as
$\bar{\bmb}=\bar{\bmb}+A^{-1}\bar{\bmx}$. In other words this is just another solve 
with the same matrix. 
Let the solver be implemented as a simple LU-factorization, see \lstinline{lu.f90}.
One can compile the original example in this directory by invoking \\[1ex]
\hspace*{.3cm}\lstinline{make} \\[1ex] 
and then invoking the resulting binary\\[1ex]
\hspace*{.3cm}\lstinline{./driver} \\[1ex]
which produces the output shown in \reffig{fig:selfAdjointDriverOutput}.
\begin{figure}[htb]
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{selfAdjointDriverOutput.txt}
\end{boxedminipage}
\caption{Output from \lstinline{driver} of the self-adjoint example.}\label{fig:selfAdjointDriverOutput}
\end{figure} 
The correctness test is also implemented in \lstinline{lu.f90}.

For the reverse mode setup we assume a simple split scheme (see also, \refsec{sec:cgReversal}) implemented in 
\lstinline{ADMsplit/}.
For the differentiation we replace the original code from \lstinline{lu.f90} with stubs provided in 
\lstinline{ADMsplit/luStubs.f90}. 
The purpose of the stub is simply to establish the data dependency for the code analysis while hiding the 
complexity of the actual code or dealing with cases where the source code is not available in the first place.
In this file we simply establish a dependency from  the right-hand-side vector \lstinline{b} to the solution 
\lstinline{x}. 
The code analysis now can trace the path from the independent to the dependent declared in 
\lstinline{head.f90}. 
The rules in \lstinline{ADMsplit/Makefile} show how the \lstinline{ADMsplit/luStubs.f90} and  
\lstinline{head.f90} are concatenaded, the module name is changed to the \lstinline{LUstubs} module,
and then the sources are transformed using the \lstinline{openad} wrapper script.

During the post processing phase we use the default split mode template copied in by the 
\lstinline{openad} script. The one exception is the transformed \lstinline{ADMsplit/luStubs.f90}
that contains the template pragma directing the post processor to use the template files
\lstinline{oad_template_solve.f90} (and also \lstinline{oad_template_test.f90})  in 
\lstinline{ADMsplit} instead. 
\begin{figure}
\begin{minipage}{\linewidth}
\small\lstinputlisting[basicstyle=,language=Fortran,frame=single]{Examples/SelfAdjoint/ADMsplit/oad_template_solve.f90}
\end{minipage}
\caption{Split mode template for LU solve (see file 
\lstinline{$OPENADROOT/Examples/SelfAdjoint/ADMsplit/oad_template_solve.f90}) %$
}\label{fig:selfAdjointSplitTemplate}
\end{figure}
Inspecting the \lstinline{ADMsplit/oad_template_solve.f90} file, see also \reffig{fig:selfAdjointSplitTemplate}
shows that we avoid a name clash by \lstinline{USE}ing the original \lstinline{solve} renamed as \lstinline{trueSolve}
and implement the forward and reverse sweeps simply as the linear system solves indicated above. 

The output created  by the \lstinline{ADMsplit/driverADMsplit} variant can be compared with the output created for finite differences with 
\lstinline{FD/driverFD}, see also \reffig{fig:selfAdjointDriverADMsplitFDOutput}.
\begin{figure}
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{selfAdjointDriverADMsplitOutput.txt}
\end{boxedminipage}
\begin{boxedminipage}{\textwidth}
\scriptsize\verbatiminput{selfAdjointDriverFDOutput.txt}
\end{boxedminipage}
\caption{Output from \lstinline{ADMsplit/driverADMsplit} (top) and \lstinline{FD/driverFD} for the self-adjoint example.}\label{fig:selfAdjointDriverADMsplitFDOutput}
\end{figure} 
% .........................................................................................
\subsection{Linear Solve with UMFPACK}\label{sec:umfpack}
Because UMFPACK \cite{umfpackWeb} is not included in the \OpenADF\ downloads you need to make sure to have it installed and have the environment variable \lstinline{UMFPACK_LID_DIR} point to the installation directory to compile and run the examples. 
We use this example to also illustrate the difference between an active and a passive system matrix. 
% .........................................................................................
\subsubsection{Passive System Matrix (UMFPACK v. 2.2)}\label{sec:umfpackPassive}  
This example refers to the old UMFPACK implementation v. 2.2.  
All related files can be found in 
\lstinline{$OPENADROOT/Examples/LibWrappers/UmfPack_2.2_passive}. %$
Similarly to \refsec{sec:selfAdjoint} we consider a linear solve but now with an unsymmetric system: 
\[
\left[\begin{array}{cc}
2 & 4 \\
3 & 2 
\end{array}\right] \bmx=\bmb \quad .
\]
As opposed to \refsec{sec:selfAdjoint}, the corresponding adjoint solve has to be done with the transpose
$\bar{\bmb}=\bar{\bmb}+A^{-T}\bar{\bmx}$.
For the solve with UMFPACK a sequence of three calls has to be issued to the routines
\lstinline{UMD21I} (initialization),  \lstinline{UMD2FA} (factorization), \lstinline{UMD2SO} (backsubstitution).
The last two calls are typically followed by error checks. Considering this calling sequence it is apparent that 
\begin{itemize} 
\item a naive reversal of the sequence will let the error checks precede the calls to be checked, and 
\item the calls themselves do not have an obvious adjoint equivalent.
\end{itemize}
The entire calling sequence as a linear solve however does.  Therefore we consider the solve as implemented in 
\lstinline{solve.f90} the unit to be wrapped. Note the \lstinline{trans} parameter to quickly switch to the 
transposed version.
Similarly to \refsec{sec:selfAdjoint} we use a stub, see \lstinline{ADMsplit/Stubs/solve.f90} for the transformation
which then is replaced in the post process step by the template indicated in the stub's template pragma, see 
\lstinline{ADMsplit/Templates/solve.f90} which is also shown in \reffig{fig:umf22passiveTemplate}.
\begin{figure}[tb]
\begin{minipage}{\linewidth}
\small\lstinputlisting[basicstyle=,language=Fortran,frame=single]{Examples/LibWrappers/UmfPack_2.2_passive/ADMsplit/Templates/solve.f90}
\end{minipage}
\caption{Split mode template for UMFPACK solve (see file 
\lstinline{$OPENADROOT/Examples/LibWrappers/UmfPack_2.2_passive/ADMsplit/Templates/solve.f90}) %$
}\label{fig:umf22passiveTemplate}
\end{figure}
Note the switch in the transpose parameter on the \lstinline{solve} call in the adjoint branch.

Also, note that in difference to \refsec{sec:selfAdjoint} we disambiguate between the stub for \lstinline{solve} 
and the actual \lstinline{solve} wrapper by forcing a rename on all routines during the transformation with 
the \lstinline{-r} switch, see \lstinline{ADMsplit/Makefile} for the command line flags passed to \lstinline{oadDriver}.
Because all routines are renamed, the calls to \lstinline{head} in the driver have to be changed to a calls to 
\lstinline{OpenAD_head}, see \lstinline{ADMsplit/driverADMsplit.f90}.    
% .........................................................................................
\subsubsection{Active System Matrix (UMFPACK v. 2.2)}  \label{sec:umfpackActive}

% #########################################################################################
\chapter{Modifying \OpenADF}\label{sec:mods}

\OpenADF\ is an AD tool built on a language independent infrastructure with 
well-separated components. 
It 
allows developers to focus on various aspects of source-to-source 
transformation AD, including parsing and unparsing of different programming
languages, data and control flow analysis, and (semantic) transformation 
algorithms.
The components have well defined interfaces and intermediate stages 
are retained as either Fortran or XML sources. 
 
\OpenADF\ allows users a great amount of flexibility in the use of the code transformation
and permits interventions at various stages of the transformation process.
We would like to emphasize the fact that for large scale applications 
the efficiency of checkpointing and taping can be improved merely by 
modifying the implementation of the run time support, the template and inlining 
code. 
They are not conceived  to be just static 
deliverables of \OpenADF\ but rather are part of the 
interface accessible to the user.
It is not the intention to stop with a few prepackaged solutions as one 
would expect from a 
monolithic, black-box tool.  
True to the nature of an open source design, the interface is instead conceived as a 
wide playground for 
experimentation and improvement. 
Expanding on the schematic depiction 
of the tool workings in \reffig{fig:overview} we want to highlight 
the options to modify the transformation and the tool itself in \reffig{fig:toolChainIntervention} 
at different levels of complexity reaching from the casual user to 
actual coding work in the tool's components.    
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{overview2}
\end{center}
\caption{Levels of complexity for modifications}\label{fig:toolChainIntervention}
\end{figure} 
As part of using \OpenADF\ for different applications we see a growing number of 
variations to the  transformation and run time support implementations available 
to the user.

Aside from the plain AD tool aspect the intention of the 
underlying \OpenAD\  framework is to 
provide the AD community with 
an open, extensible, and easy-to-use platform for research and development
that can be applied across programming languages.
Tools that have a closer coupling with a language-specific, internal representation
have the potential to make the exploitation of certain language features easier. 
Consequently we do not expect \OpenADF\ to obsolete existing source transformation
tools such as  
the differentiation-enabled NAG Fortran 95 
compiler,
\footnote{\url{http://www.nag.co.uk/nagware/research/ad_overview.asp}} 
TAF,\footnote{\url{http://www.FastOpt.de}} 
or TAPENADE.\footnote{\url{http://tapenade.inria.fr:8080/tapenade/index.jsp}} 
Rather it is to
complement these tools by providing well-defined APIs to an open internal 
representation that can be used by a large number of AD developers.
Users of AD technology will benefit from the expected
variety of combinations of front-ends and algorithms that is made possible
by \OpenADF.

As with any software project there is ample room for improvement.
The robustness of the tool, in particular the coverage of 
some specific language features, often is of concern to first 
time users. While robustness is not to be disregarded, it is clearly 
not a research subject and as such cannot be made the major 
objective of a development project in an academic setting. 
Robustness issues affect mostly the language dependent components 
and the contributing parties undertake a considerable effort to 
address concerns common to many applications. Many issues specific 
to a particular input code can be addressed by minor adjustments 
which often happen to reflect good coding practices anyway. 
Take for example a change away from 
\lstinline{goto - label} to a well structured control flow. 
While we plan to  implement code that handles 
unstructured control flow at some point, the corresponding adjoint  will always
be less efficient than the respective structured equivalent and an 
automatic transformation to structured control flow is somewhat beyond the scope
of an AD tool.

We are concerned with changes that affect many applications and yield 
improved efficiency of the adjoint code.
Currently the most important items on the development list are the
support for vector intrinsics and the handling of allocation/deallocation cycles 
during the model computation for the generation of an adjoint model.
Because the tool provides a variety of options to the user we are also 
working on collecting data for efficiency estimates that permit 
an informed choice between the code transformation options. 
Ongoing research in AD algorithms, in particular dynamic call 
graph reversal, more efficient control flow reversal and 
improved elimination techniques in the computational graphs will 
be incorporated into \OpenAD. 

% #########################################################################################
\chapter{Miscellaneous}\label{sec:misc}
% -----------------------------------------------------------------------------------------
\section{Changes relative to the ACM TOMS paper}\label{sec:changesSinceTOMS}
Because of continued development since \cite{Utke2008OAM} was finalized 
we maintain the following list of significant changes.
\begin{description} 
\item[Renamed files and directories] In a number of cases the names and locations of files and 
tool components turned out to be inappropriate or misleading. Consequently a number of changes 
have been introduced to rectify the situation.  
{
\begin{itemize}
\item The binaries in \lstinline{test/t} under \lstinline{$OPENADROOT/xaifBooster/system} %$ 
and the algorithm directories have been renamed to \lstinline{driver/oadDriver} and the 
underlying source files from \lstinline{t.cpp} to \lstinline{oadDriver.cpp}.
\item the script to get the components has been renamed from \lstinline{goad} to \lstinline{openadUpdate}
and command line flags have been added.
\end{itemize}
}
\item[Changed command line flags]
\begin{itemize}
\item the replacement for the \lstinline{goad} script which is called \lstinline{openadUpdate} has command 
line flags that were not present for \lstinline{goad}. Details can be found in \refsec{sec:ancillaryTools}.
\end{itemize}
\item[Refactorized Algorithms]
\end{description}
% -----------------------------------------------------------------------------------------
\section{Regression Tests}\label{sec:regression}
All regression tests can be added to the \OpenAD\ source tree using the \lstinline{-t} 
flag with the \lstinline{openadUpdate} script, see \refsec{sec:openadUpdate}.
The  test setups are in the following locations. 
\begin{itemize}
\item\lstinline{$OPENAD/Regression/}%$
which exercises the entire tool chain (requires \lstinline{gnuplot} \footnote{
see \url{http://www.gnuplot.info/}})
\item\lstinline{$OPENAD/OpenADFortTk/Regression/}%$
which exercises the translation between \whirl\ and \xaif, see \refsec{sec:wtxxtw} 
\item\lstinline{$OPENAD/OpenADFortTk/tools/SourceProcessing/Regression/}%$
which exercises the Fortran parser that is used in the pre and post processing, see \refsecs{sec:Canonicalization}{sec:PostProcessor} 
\item\lstinline{$OPENAD/Open64/osprey1.0/tests/}%$
which is included in the \OpenSixtyFour\ repository and exercises the Fortran frontend, see \refsec{sec:open64FeBe}
\end{itemize}
In each directory is a main driver script called \lstinline{testAll.py}. 
The \lstinline{-h} option shows all available options which are self 
explanatory.  Note that the test sets include test cases that have been included 
to illustrate certain problems with the tool and not all of these problems have 
been fixed. The expected outcome is kept in the respective reference outputs 
and the latest update is listed in tables on the \OpenAD\ website. 
With the \lstinline{-i} option the \lstinline{testAll.py} script will skip test cases  
expected to fail and otherwise prompt for execution. 
All test sets except for the first one have a simple boolean outcome. 
Exercising the entire tool chain permits a consistency check against finite differences. 
We use a default tolerance to accomodate variations in hardware, compilers and 
compiler optimization but for 
some problems because of cancellations etc the tolerance is exceeded either for the 
absolute or relative discrepancy. 
To facilitate maximal use of the test cases we  compare the  intermediate stages of the 
transformation in the tool chain are kept as references for forward and reverse mode (joint and 
split) setup. To illustrate the numerical comparison we use a test called \lstinline{boxmodel}
that can in the \lstinline{$OPENAD/OpenADFortTk/Regression/}%$ 
invoke like this\\[1ex]
\hspace*{.3cm}\lstinline{./testAll.py  boxmodel}\\[1ex]
Hitting \lstinline{enter} on all subsequent prompts will execute the test case
with the default settings (forward mode using the \lstinline{ifort} compiler without 
optimization but extra checking enabled). 
The numerical discrepancies are shown using gnuplot with output similar to the 
the one shown in \reffig{fig:numericalDiscrepancy}.
\begin{figure}
  \centering\includegraphics[width=.5\textwidth]{numericalDiscrepancy}
  \caption{Example for numerical discrepancy shown for test case \lstinline{boxmodel} 
for forward mode.} \label{fig:numericalDiscrepancy}
\end{figure} 

 
% -----------------------------------------------------------------------------------------
\section{Compiling and Contributing to this Manual}\label{sec:compilingManual}
The \LaTeX\ sources of this manual are kept under 
mercurial revision control. Details how to download 
the manual can be found on the \OpenADF\ website under ``How to Contribute''.  
In addition to \LaTeX  (in particular \lstinline{pdflatex}) 
one also needs \lstinline{dot}, \lstinline{fig2dev}, and 
\lstinline{dia} for the conversion of figures. 
The manual's \lstinline{Makefile} requires a source installation of \OpenADF\
from the source code repository with all extra tests and examples using \\[1ex]
\hspace*{.3cm}\lstinline{openadUpdate -et}\\[1ex]
including the prerequisites to run regression tests, see \refsec{sec:regression}.
The environment must be setup as described in \refsec{sec:env}.
The manual refers to a {\bf set of code examples} which are 
linked from the \OpenADF\ installation by the \lstinline{Makefile}.
It can be build in one step as follows.\\[1ex]
\hspace*{.3cm}\lstinline{cd OpenADF_Manual/Manual}\\
\hspace*{.3cm}\lstinline{make}\\[1ex]
   
% #########################################################################################
\chapter*{Appendix}
\begin{table}
  \tiny
  \begin{center}
    \begin{tabular}{ll}
      {\tt Makefile} & the top level {\tt Makefile}\\
      {\tt utils/} & utility classes (debugging, generic traversal, etc.)\\
      {\tt tools/}  & code generator supporting \xaif\ parser \\
      {\tt boostWrapper/}& wrapper classes for the boost graph library \\
      {\tt system/} & all basic data structures, \xaif\ (un)parsing, \refsec{sec:readWriteXaif}\\
      {\tt algorithms/}& see the subdirectories below\\
      \quad{\tt CodeReplacement} & support library for subroutine templates\\
      \quad{\tt CrossCountryInterface} & support library for elimination strategies, \refsec{sec:BBPreacc}\\
      \quad{\tt DerivativePropagator} & support library for Jacobian vector products\\
      \quad{\tt InlinableXMLRepresentation } & support library for inlinable subroutine calls\\ 
      \quad{\tt Linearization} & Linearization transformation, \refsec{sec:linearization}\\ 
      \quad{\tt BasicBlockPreaccumulation} & elimination with \angel\ and \\
      & preaccumulation at the \basicblock\ level, \refsec{sec:BBPreacc}\\
      \quad{\tt  MemOpsTradeoffPreaccumulation} & as above but with different heuristics than \angel\\
      \quad{\tt ControlFlowReversal} & control flow graph reversal\\
      \quad{\tt BasicBlockPreaccumulationReverse } & adjoint code\\
      \quad{\tt BasicBlockPreaccumulationTape } & taping code supporting adjoint, \refsec{sec:bbTA}\\
      \quad{\tt BasicBlockPreaccumulationTapeAdjoint } & reverse sweep portion supporting adjoint,\refsec{sec:bbTA}\\
    \end{tabular}
  \end{center}
  \caption{Directory structure in \xaifBooster}\label{tab:dirStruct}
\end{table}
\bibliographystyle{plain}
\bibliography{openad}
\include{index}
  \addcontentsline{toc}{chapter}{Index}
\end{document}
